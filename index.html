<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÊòüÊ†∏Êô∂‰Ωì v15</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Courier New', monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* ÊëÑÂÉèÂ§¥È¢ÑËßà */
        #video-input { 
            position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px; 
            transform: scaleX(-1); opacity: 0.3; z-index: 2; 
            border: 2px solid #4facfe; border-radius: 4px;
            pointer-events: none; mix-blend-mode: screen;
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.4);
        }
        
        /* HUD */
        #hud-top {
            position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; z-index: 5;
        }
        .hud-text {
            color: #4facfe; font-size: 16px; letter-spacing: 4px; text-transform: uppercase;
            text-shadow: 0 0 10px rgba(79, 172, 254, 0.8);
        }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 14px; z-index: 20; pointer-events: none;
            letter-spacing: 4px; text-transform: uppercase; border: 1px solid #4facfe;
            padding: 15px 30px; background: rgba(0,0,0,0.8);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.3);
        }

        /* GUI */
        .lil-gui { 
            --background-color: rgba(5, 8, 15, 0.9); 
            --text-color: #eee; 
            --title-background-color: #0b1a2f;
            --widget-color: #222;
            --focus-color: #4facfe;
            --width: 240px;
            border: 1px solid rgba(79, 172, 254, 0.5);
        }
        .lil-gui .title { color: #4facfe; font-weight: bold; }
    </style>
</head>
<body>

    <div id="hud-top"><span class="hud-text">SYSTEM ONLINE: VOXEL ENGINE</span></div>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <div id="loader">Initializing...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // --- Ê†∏ÂøÉÈÖçÁΩÆ ---
        const config = {
            count: 5000,          // Á≤íÂ≠êÊï∞ (‰øùÊåÅ v11 ÁöÑÈáèÁ∫ß‰ª•‰øùËØÅÊÄßËÉΩ)
            voxelSize: 0.45,      // Êô∂‰ΩìÂü∫Á°ÄÂ§ßÂ∞è
            target: 'earth',      
            bloomStrength: 1.5,   
            bloomRadius: 0.5,
            handZoomSpeed: 0.1,
            handRotateSpeed: 3.0,
            autoRotate: true
        };

        // --- È¢úËâ≤ÂÆö‰πâ ---
        const C = {
            blue: new THREE.Color(0x4facfe),     
            cyan: new THREE.Color(0x00f2fe),     
            white: new THREE.Color(0xffffff),    
            purple: new THREE.Color(0x9b59b6),   
            gold: new THREE.Color(0xffd700),     
            orange: new THREE.Color(0xff8c00),   
            red: new THREE.Color(0xff3333),      
            deepBlue: new THREE.Color(0x00008b), 
            grey: new THREE.Color(0xa9a9a9)      
        };

        // --- Âô™Â£∞ÂáΩÊï∞ (ÂÜÖÁΩÆÔºåÈò≤Ê≠¢Ë∑®ÂüüÊä•Èîô) ---
        class ImprovedNoise{constructor(){const p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];for(let i=0;i<256;i++)p[256+i]=p[i];this.p=p}noise(x,y,z){const p=this.p,fade=t=>t*t*t*(t*(t*6-15)+10),lerp=(t,a,b)=>a+t*(b-a),grad=(hash,x,y,z)=>{const h=hash&15,u=h<8?x:y,v=h<4?y:h===12||h===14?x:z;return((h&1)===0?u:-u)+((h&2)===0?v:-v)};const X=Math.floor(x)&255,Y=Math.floor(y)&255,Z=Math.floor(z)&255;x-=Math.floor(x);y-=Math.floor(y);z-=Math.floor(z);const u=fade(x),v=fade(y),w=fade(z);const A=p[X]+Y,AA=p[A]+Z,AB=p[A+1]+Z,B=p[X+1]+Y,BA=p[B]+Z,BB=p[B+1]+Z;return lerp(w,lerp(v,lerp(u,grad(p[AA],x,y,z),grad(p[BA],x-1,y,z)),lerp(u,grad(p[AB],x,y-1,z),grad(p[BB],x-1,y-1,z))),lerp(v,lerp(u,grad(p[AA+1],x,y,z-1),grad(p[BA+1],x-1,y,z-1)),lerp(u,grad(p[AB+1],x,y-1,z-1),grad(p[BB+1],x-1,y-1,z-1))))}}
        const noise = new ImprovedNoise();

        // --- Âú∫ÊôØÊê≠Âª∫ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020204); 
        scene.fog = new THREE.FogExp2(0x020204, 0.02);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.z = 35;

        const renderer = new THREE.WebGLRenderer({ antialias: false }); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // --- Bloom ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = config.bloomStrength;
        bloomPass.radius = config.bloomRadius;
        composer.addPass(bloomPass);

        // --- Ê†∏ÂøÉÔºöInstancedMesh (ËøôÂ∞±ÊòØ v11 Á®≥ÂÆöÁöÑÂÖ≥ÈîÆ) ---
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff }); // È¢úËâ≤Áî± InstanceColor ÊéßÂà∂
        const mesh = new THREE.InstancedMesh(geometry, material, config.count);
        scene.add(mesh);

        const dummy = new THREE.Object3D();
        const positions = [];       
        const targetPositions = []; 
        const currentColors = [];   
        const targetColors = [];    

        // ÂàùÂßãÂåñÊï∞ÁªÑ
        for(let i=0; i<config.count; i++) {
            positions.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
            targetPositions.push(0,0,0);
            currentColors.push(0,0,1);
            targetColors.push(0,0,1);
        }

        // --- ÁÆÄÂçïÁöÑÂô™Â£∞ÂáΩÊï∞ ---
        function simpleNoise(x, y, z) {
            return Math.sin(x*10 + Math.cos(y*12 + z*15)) * 0.5 + 0.5;
        }

        // --- ÂΩ¢Áä∂ËÆ°ÁÆóÈÄªËæë (Â§™Èò≥Á≥ªÂÖ®ÂÆ∂Ê°∂) ---
        function calculateLayout(type) {
            const rBase = 12; // Âü∫Á°ÄÂçäÂæÑ

            for (let i = 0; i < config.count; i++) {
                let x, y, z;
                let c = C.blue;
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // --- ÊòüÁêÉÁâπËâ≤ÈÄªËæë ---
                if (type === 'sun') { // ‚òÄÔ∏è Â§™Èò≥
                    const r = rBase * (0.7 + Math.random() * 0.4);
                    const spike = Math.random() > 0.9 ? 1.4 : 1.0;
                    x = r * spike * Math.sin(phi) * Math.cos(theta);
                    y = r * spike * Math.sin(phi) * Math.sin(theta);
                    z = r * spike * Math.cos(phi);
                    const mix = Math.random();
                    if(mix > 0.6) c = C.white; else if(mix > 0.2) c = C.orange; else c = C.gold;

                } else if (type === 'mercury') { // üåë Ê∞¥Êòü
                    const r = rBase * 0.6;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    if (Math.random() > 0.8) { x*=0.95; y*=0.95; z*=0.95; }
                    c = C.grey.clone().lerp(C.blue, 0.3);

                } else if (type === 'venus') { // üåï ÈáëÊòü
                    const r = rBase * 0.9;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    c = C.gold.clone().lerp(C.white, Math.random()*0.5);

                } else if (type === 'earth') { // üåç Âú∞ÁêÉ
                    let r = rBase;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    const noiseVal = simpleNoise(x*0.1, y*0.1, z*0.1);
                    if (noiseVal > 0.65) { c = new THREE.Color(0x22ee22); x *= 1.03; y *= 1.03; z *= 1.03; } // Áªø
                    else if (Math.random() > 0.9) { c = C.white; x *= 1.1; y *= 1.1; z *= 1.1; } // ‰∫ë
                    else c = C.blue.clone().lerp(C.deepBlue, Math.random()); // Ëìù

                } else if (type === 'mars') { // üî¥ ÁÅ´Êòü
                    const r = rBase * 0.7;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    if(simpleNoise(x*0.2,y*0.2,z*0.2)>0.6) { x*=1.05; y*=1.05; z*=1.05; }
                    c = C.red.clone().lerp(C.orange, Math.random()*0.5);

                } else if (type === 'jupiter') { // üçò Êú®Êòü
                    const r = rBase * 1.4;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    const band = Math.sin(y * 1.5 + simpleNoise(x,0,z)); 
                    if (band > 0.5) c = C.orange; else if (band > 0) c = C.gold; else c = C.blue.clone().lerp(C.grey, 0.5);

                } else if (type === 'saturn') { // ü™ê ÂúüÊòü
                    if (i < config.count * 0.4) {
                        const r = rBase * 1.1;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                        c = C.gold.clone().multiplyScalar(0.7);
                    } else {
                        const ringR = rBase * (1.6 + Math.random()*1.2);
                        const angle = Math.random() * Math.PI * 2;
                        x = ringR * Math.cos(angle);
                        z = ringR * Math.sin(angle);
                        y = (Math.random()-0.5) * 0.6; 
                        c = C.blue.clone().lerp(C.white, Math.random());
                    }

                } else if (type === 'uranus') { // ‚öôÔ∏è Â§©ÁéãÊòü
                    if (i < config.count * 0.5) {
                        const r = rBase * 1.0;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                        c = C.cyan;
                    } else {
                        const ringR = rBase * (1.5 + Math.random()*0.8);
                        const angle = Math.random() * Math.PI * 2;
                        x = ringR * Math.cos(angle);
                        y = ringR * Math.sin(angle);
                        z = (Math.random()-0.5) * 0.4;
                        c = C.white.clone().multiplyScalar(0.8);
                    }

                } else if (type === 'neptune') { // üîµ Êµ∑ÁéãÊòü
                    const r = rBase * 1.0;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    c = C.deepBlue.clone().lerp(C.blue, Math.random()*0.3);

                } else if (type === 'galaxy') { // üåå Èì∂Ê≤≥
                    const arm = i % 4;
                    const r = Math.random() * rBase * 2.0;
                    const angle = r * 0.4 + (arm * Math.PI * 2 / 4);
                    x = r * Math.cos(angle) + (Math.random()-0.5)*3;
                    z = r * Math.sin(angle) + (Math.random()-0.5)*3;
                    y = (Math.random()-0.5) * (20 - r*0.6);
                    if (r/rBase < 0.2) c = C.white; else if (r/rBase < 1.0) c = C.purple; else c = C.blue;
                }

                targetPositions[i*3] = x; targetPositions[i*3+1] = y; targetPositions[i*3+2] = z;
                targetColors[i*3] = c.r; targetColors[i*3+1] = c.g; targetColors[i*3+2] = c.b;
            }
        }

        calculateLayout(config.target); // Á´ãÂç≥ËÆ°ÁÆó

        // --- ÊâãÂäøÊéßÂà∂ ---
        let targetZoom = 35;
        let targetRotY = 0;
        
        const videoElement = document.getElementById('video-input');
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hands = results.multiHandLandmarks;
                let pinchDist = 0;
                let centerX = 0.5;

                if (hands.length === 2) {
                    const h1 = hands[0][0]; const h2 = hands[1][0];
                    pinchDist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                    centerX = (h1.x + h2.x) / 2;
                } else {
                    const thumb = hands[0][4]; const pinky = hands[0][20];
                    pinchDist = Math.hypot(thumb.x - pinky.x, thumb.y - pinky.y) * 2;
                    centerX = hands[0][9].x;
                }
                const zoomFactor = 1.0 - Math.min(Math.max(pinchDist, 0.1), 0.8);
                targetZoom = 15 + zoomFactor * 50;
                targetRotY += (centerX - 0.5) * config.handRotateSpeed * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });
        cameraUtils.start();

        // --- GUI (‰øÆÂ§ç‰∫ÜËøôÈáåÔºÅ) ---
        const gui = new GUI({ title: 'CONTROL PANEL' });
        const targets = { 
            '‚òÄÔ∏è SUN': 'sun', 'üåë MERCURY': 'mercury', 'üåï VENUS': 'venus',
            'üåç EARTH': 'earth', 'üî¥ MARS': 'mars', 'üçò JUPITER': 'jupiter',
            'ü™ê SATURN': 'saturn', '‚öôÔ∏è URANUS': 'uranus', 'üîµ NEPTUNE': 'neptune', 
            'üåå GALAXY': 'galaxy'
        };
        gui.add(config, 'target', targets).name('TARGET').onChange(v => calculateLayout(v));
        // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöËøôÈáåÁªëÂÆöÁöÑÊòØ config.voxelSizeÔºå‰∏çÂÜçÊòØ material.size
        gui.add(config, 'voxelSize', 0.1, 1.0).name('VOXEL SIZE'); 
        gui.add(config, 'bloomStrength', 0, 3).name('NEON GLOW').onChange(v => bloomPass.strength = v);
        gui.add(config, 'autoRotate').name('AUTO ROTATE');

        // --- Âä®ÁîªÂæ™ÁéØ ---
        function animate() {
            requestAnimationFrame(animate);

            // ÊëÑÂÉèÊú∫
            camera.position.z += (targetZoom - camera.position.z) * 0.05;
            mesh.rotation.y += (targetRotY - mesh.rotation.y) * 0.05;
            if(config.autoRotate) mesh.rotation.y += 0.002;
            mesh.rotation.x = Math.sin(Date.now()*0.0005) * 0.05;

            // Á≤íÂ≠êÊõ¥Êñ∞
            const time = Date.now() * 0.001;
            const tempColor = new THREE.Color();
            
            // Á°Æ‰øù mesh Â≠òÂú®ÊâçÊõ¥Êñ∞
            if (mesh) {
                for (let i = 0; i < config.count; i++) {
                    const ix = i * 3; const iy = i * 3 + 1; const iz = i * 3 + 2;
                    
                    positions[ix] += (targetPositions[ix] - positions[ix]) * 0.08;
                    positions[iy] += (targetPositions[iy] - positions[iy]) * 0.08;
                    positions[iz] += (targetPositions[iz] - positions[iz]) * 0.08;

                    currentColors[ix] += (targetColors[ix] - currentColors[ix]) * 0.05;
                    currentColors[iy] += (targetColors[iy] - currentColors[iy]) * 0.05;
                    currentColors[iz] += (targetColors[iz] - currentColors[iz]) * 0.05;

                    dummy.position.set(positions[ix], positions[iy], positions[iz]);
                    
                    // ÂëºÂê∏ÊïàÊûú + Â∞∫ÂØ∏ÊéßÂà∂
                    const breath = 0.8 + 0.3 * Math.sin(time * 3 + i * 0.05);
                    const scale = config.voxelSize * breath;
                    dummy.scale.set(scale, scale, scale);
                    
                    dummy.rotation.set(time + i, time * 0.5 + i, 0);

                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    
                    tempColor.setRGB(currentColors[ix], currentColors[iy], currentColors[iz]);
                    mesh.setColorAt(i, tempColor);
                }
                mesh.instanceMatrix.needsUpdate = true;
                mesh.instanceColor.needsUpdate = true;
            }

            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
