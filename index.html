<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤ªé˜³ç³»å…¨æ¯æŠ•å½±v9.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: #000; }
        
        /* æ‘„åƒå¤´é¢„è§ˆ - æ”¾åœ¨å·¦ä¸‹è§’ï¼ŒåŠé€æ˜ */
        #video-input { 
            position: absolute; bottom: 10px; left: 10px; width: 120px; height: 90px; 
            transform: scaleX(-1); border-radius: 8px; opacity: 0.3; z-index: 2; 
            border: 1px solid rgba(255,255,255,0.1); pointer-events: none; 
            transition: opacity 0.3s; mix-blend-mode: screen; 
        }
        #video-input.active { opacity: 0.6; }
        
        #fs-btn {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            background: rgba(0, 0, 0, 0.5); color: #4da6ff; border: 1px solid rgba(77, 166, 255, 0.3);
            padding: 8px 16px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(5px);
            transition: all 0.3s; font-size: 13px; letter-spacing: 1px; text-transform: uppercase;
        }
        #fs-btn:hover { background: #4da6ff; color: #000; box-shadow: 0 0 15px rgba(77, 166, 255, 0.5); }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #4da6ff; font-size: 16px; z-index: 20; pointer-events: none;
            text-align: center; font-weight: 300; letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(77, 166, 255, 0.5);
        }

        /* ä¼˜åŒ– GUI æ ·å¼ */
        .lil-gui { --width: 280px; --name-width: 35%; --background-color: rgba(5, 10, 20, 0.85); --text-color: #eee; --widget-color: #333; --focus-color: #4da6ff; }
        .lil-gui .title { color: #4da6ff; font-weight: bold; text-align: center; }
    </style>
</head>
<body>

    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <button id="fs-btn">è¿›å…¥æ²‰æµ¸æ¨¡å¼</button>
    <div id="loader">æ­£åœ¨åˆå§‹åŒ–å…¨æ¯ç³»ç»Ÿ...<br><span style="font-size:12px; opacity:0.6;">è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¯ç”¨æ‰‹åŠ¿æ§åˆ¶</span></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // --- é…ç½®é¡¹ ---
        const config = {
            target: 'earth', 
            particleCount: 60000, // 6ä¸‡ç²’å­ï¼Œæ€§èƒ½ä¸æ•ˆæœçš„å¹³è¡¡ç‚¹
            particleSize: 0.04,   // ç²’å­ç¨å¾®å°ä¸€ç‚¹ï¼Œé…åˆè¾‰å…‰
            handSensitivity: 2.5,
            autoRotate: true,
            bloomStrength: 1.0,   // è¾‰å…‰å¼ºåº¦
            bloomRadius: 0.5
        };

        // --- å†…ç½® ImprovedNoise (é¿å… CORS é—®é¢˜) ---
        class ImprovedNoise{constructor(){const p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];for(let i=0;i<256;i++)p[256+i]=p[i];this.p=p}noise(x,y,z){const p=this.p,fade=t=>t*t*t*(t*(t*6-15)+10),lerp=(t,a,b)=>a+t*(b-a),grad=(hash,x,y,z)=>{const h=hash&15,u=h<8?x:y,v=h<4?y:h===12||h===14?x:z;return((h&1)===0?u:-u)+((h&2)===0?v:-v)};const X=Math.floor(x)&255,Y=Math.floor(y)&255,Z=Math.floor(z)&255;x-=Math.floor(x);y-=Math.floor(y);z-=Math.floor(z);const u=fade(x),v=fade(y),w=fade(z);const A=p[X]+Y,AA=p[A]+Z,AB=p[A+1]+Z,B=p[X+1]+Y,BA=p[B]+Z,BB=p[B+1]+Z;return lerp(w,lerp(v,lerp(u,grad(p[AA],x,y,z),grad(p[BA],x-1,y,z)),lerp(u,grad(p[AB],x,y-1,z),grad(p[BB],x-1,y-1,z))),lerp(v,lerp(u,grad(p[AA+1],x,y,z-1),grad(p[BA+1],x-1,y,z-1)),lerp(u,grad(p[AB+1],x,y-1,z-1),grad(p[BB+1],x-1,y-1,z-1))))}}

        // --- è¡Œæ˜Ÿæ•°æ® ---
        const planetData = {
            'sun':     { name: 'â˜€ï¸ å¤ªé˜³ Sun', radius: 22, colors: [0xffaa00, 0xff4400, 0xffffff, 0xff0000], type: 'sun' },
            'mercury': { name: 'æ°´æ˜Ÿ Mercury', radius: 10, colors: [0xa1a1a1, 0x787878, 0xefefef], type: 'rocky' },
            'venus':   { name: 'é‡‘æ˜Ÿ Venus', radius: 12, colors: [0xffd700, 0xffa500, 0xeeeeaa], type: 'atmosphere' },
            'earth':   { name: 'ğŸŒ åœ°çƒ Earth', radius: 13, colors: [0x1133ff, 0x0088ff, 0x228822, 0xffffff], type: 'earth' },
            'mars':    { name: 'ç«æ˜Ÿ Mars', radius: 11, colors: [0xcc3311, 0xaa2200, 0xff6633], type: 'rocky' },
            'jupiter': { name: 'æœ¨æ˜Ÿ Jupiter', radius: 20, colors: [0xdcb185, 0xbf9b7a, 0x8a6d52, 0xf0e0d0], type: 'banded' },
            'saturn':  { name: 'ğŸª åœŸæ˜Ÿ Saturn', radius: 17, colors: [0xe3dccb, 0xcabda5], type: 'ringed' },
            'uranus':  { name: 'å¤©ç‹æ˜Ÿ Uranus', radius: 15, colors: [0x88ffff, 0x44ccff, 0xccffff], type: 'ringed_tilt' },
            'neptune': { name: 'æµ·ç‹æ˜Ÿ Neptune', radius: 15, colors: [0x3333ff, 0x2222dd, 0x5555ff], type: 'atmosphere' },
            'galaxy':  { name: 'ğŸŒŒ é“¶æ²³ç³» Galaxy', radius: 30, colors: [0xffaa55, 0xff4488, 0x4422ff, 0xffffff], type: 'galaxy' }
        };

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.005); // æ·±ç©ºé»‘é›¾

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 45;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- åæœŸå¤„ç† (è¾‰å…‰) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.85);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- æ˜Ÿç©ºèƒŒæ™¯ ---
        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const positions = [];
            for(let i=0; i<3000; i++) {
                const r = 300 + Math.random()*200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                positions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const starMat = new THREE.PointsMaterial({color:0xaaaaaa, size:0.7, transparent:true, opacity:0.6});
            scene.add(new THREE.Points(starGeo, starMat));
        }
        createStars();

        // --- æ ¸å¿ƒå˜é‡ ---
        let mainPoints, mainGeometry, mainMaterial;
        const targetPositions = [];
        const baseColors = new Float32Array(config.particleCount * 3);
        const noise = new ImprovedNoise();
        let handData = { detected: false, distanceSmooth: 0 };

        // --- ç²’å­çº¹ç† ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.2, 'rgba(255,255,255,0.6)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- ç²’å­ç³»ç»Ÿåˆå§‹åŒ– ---
        function initMainParticles() {
            if (mainPoints) scene.remove(mainPoints);
            
            const posArray = new Float32Array(config.particleCount * 3);
            const colArray = new Float32Array(config.particleCount * 3);

            for (let i = 0; i < config.particleCount; i++) {
                // åˆå§‹éšæœºåˆ†å¸ƒ
                const r = 50 * Math.random();
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                posArray[i*3] = r * Math.sin(phi) * Math.cos(theta);
                posArray[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                posArray[i*3+2] = r * Math.cos(phi);
                
                colArray[i*3] = 1; colArray[i*3+1] = 1; colArray[i*3+2] = 1;
            }

            mainGeometry = new THREE.BufferGeometry();
            mainGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            mainGeometry.setAttribute('color', new THREE.BufferAttribute(colArray, 3));

            mainMaterial = new THREE.PointsMaterial({
                size: config.particleSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: createGlowTexture()
            });

            mainPoints = new THREE.Points(mainGeometry, mainMaterial);
            scene.add(mainPoints);
            calculateTarget(config.target);
        }

        // --- å½¢çŠ¶è®¡ç®—é€»è¾‘ ---
        function calculateTarget(key) {
            targetPositions.length = 0;
            const data = planetData[key];
            const radius = data.radius;
            const colors = data.colors.map(c => new THREE.Color(c));

            for (let i = 0; i < config.particleCount; i++) {
                let x, y, z;
                let particleColor;
                
                // é€šç”¨çƒä½“å‚æ•°
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                let rFinal = radius;

                // --- é€»è¾‘åˆ†æ”¯ ---
                if (data.type === 'sun') {
                    // å¤ªé˜³ï¼šåŠ¨æ€çš„ã€å‘å¤–å–·å°„çš„è¡¨é¢
                    rFinal = radius * (0.9 + Math.random()*0.2);
                    const n = noise.noise(theta*3, phi*3, i*0.01);
                    if (n > 0.6) particleColor = colors[3]; // è€€æ–‘
                    else if (n > 0.3) particleColor = colors[2]; 
                    else particleColor = colors[0].clone().lerp(colors[1], Math.random());
                    
                } else if (data.type === 'earth') {
                    // åœ°çƒï¼šå™ªç‚¹ç”Ÿæˆå¤§é™†
                    rFinal = radius;
                    const nLand = noise.noise(Math.sin(phi)*4, Math.cos(theta)*4, 10);
                    const nCloud = noise.noise(Math.sin(phi)*6, Math.cos(theta)*6, i*0.1);
                    const lat = Math.abs(Math.cos(phi)); // 0èµ¤é“, 1æåœ°

                    if (nCloud > 0.6) {
                        rFinal += 0.4; // äº‘å±‚é«˜ä¸€ç‚¹
                        particleColor = colors[3]; // ç™½äº‘
                    } else if (nLand > 0.55 && lat < 0.9) {
                        particleColor = colors[2]; // ç»¿åœ°
                    } else {
                        particleColor = colors[0].clone().lerp(colors[1], lat); // è“æµ·
                    }

                } else if (data.type === 'banded') {
                    // æœ¨æ˜Ÿï¼šæ¡çº¹
                    const lat = Math.cos(phi); // -1 to 1
                    const band = Math.sin(lat * 20 + noise.noise(theta, 0, 0)*2); // æ‰­æ›²æ¡çº¹
                    const cIdx = Math.floor((band * 0.5 + 0.5) * (colors.length - 0.1));
                    particleColor = colors[cIdx];

                } else if (data.type === 'ringed' || data.type === 'ringed_tilt') {
                    // åœŸæ˜Ÿ/å¤©ç‹æ˜Ÿï¼šå…‰ç¯é€»è¾‘
                    const isRing = Math.random() > 0.65; // 35% æœ¬ä½“, 65% å…‰ç¯
                    
                    if (!isRing) {
                        rFinal = radius * 0.95; // æœ¬ä½“ç•¥å°
                        particleColor = colors[0];
                    } else {
                        // å…‰ç¯
                        const ringR = radius * (1.4 + Math.random() * 1.0);
                        const ringThick = 0.2;
                        x = ringR * Math.cos(theta);
                        z = ringR * Math.sin(theta);
                        y = (Math.random()-0.5) * ringThick;

                        // å¤©ç‹æ˜Ÿå…‰ç¯æ˜¯ç«–ç€çš„ (Zè½´æ—‹è½¬90åº¦)
                        if (data.type === 'ringed_tilt') {
                            const temp = x; x = y; y = temp; 
                        }

                        particleColor = colors[1].clone().multiplyScalar(0.7); // ç•¥æš—
                        targetPositions.push(x, y, z);
                        baseColors[i*3]=particleColor.r; baseColors[i*3+1]=particleColor.g; baseColors[i*3+2]=particleColor.b;
                        continue; 
                    }

                } else if (data.type === 'galaxy') {
                    // é“¶æ²³ç³»ï¼šæ—‹è‡‚
                    const armCount = 2;
                    const spin = i % armCount;
                    const r = radius * Math.pow(Math.random(), 0.5); // ä¸­å¿ƒå¯†é›†
                    const spiral = theta + r * 0.3 + (spin * Math.PI * 2 / armCount);
                    
                    x = r * Math.cos(spiral);
                    z = r * Math.sin(spiral);
                    y = (Math.random()-0.5) * (radius - r) * 0.4; // ä¸­å¿ƒåš

                    const dist = r / radius;
                    if (dist < 0.15) particleColor = colors[3]; // Core
                    else if (dist < 0.5) particleColor = colors[0];
                    else if (dist < 0.8) particleColor = colors[1];
                    else particleColor = colors[2];

                    targetPositions.push(x, y, z);
                    baseColors[i*3]=particleColor.r; baseColors[i*3+1]=particleColor.g; baseColors[i*3+2]=particleColor.b;
                    continue;

                } else {
                    // é»˜è®¤ (å²©çŸ³/å¤§æ°”)
                    particleColor = colors[Math.floor(Math.random()*colors.length)];
                    rFinal = radius * (0.98 + Math.random()*0.04);
                }

                // è½¬æ¢æ ‡å‡†çƒä½“åæ ‡
                if (!x) { // å¦‚æœä¸Šé¢æ²¡æœ‰è®¡ç®—è¿‡(æ¯”å¦‚å…‰ç¯)
                    x = rFinal * Math.sin(phi) * Math.cos(theta);
                    y = rFinal * Math.sin(phi) * Math.sin(theta);
                    z = rFinal * Math.cos(phi);
                }

                targetPositions.push(x, y, z);
                baseColors[i*3] = particleColor.r;
                baseColors[i*3+1] = particleColor.g;
                baseColors[i*3+2] = particleColor.b;
            }
        }

        // --- æ‰‹åŠ¿è¿½è¸ª ---
        const videoElement = document.getElementById('video-input');
        function onHandsResults(results) {
            document.getElementById('loader').style.display = 'none';
            videoElement.classList.add('active');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handData.detected = true;
                const hands = results.multiHandLandmarks;
                let dist = 0;
                
                if (hands.length === 2) {
                    // åŒæ‰‹è·ç¦»
                    const p1 = hands[0][9]; const p2 = hands[1][9];
                    dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                } else {
                    // å•æ‰‹å¼ å¼€è·ç¦» (æ‹‡æŒ‡-å°æŒ‡)
                    const p1 = hands[0][4]; const p2 = hands[0][20];
                    dist = Math.hypot(p1.x - p2.x, p1.y - p2.y) * 2.0;
                }
                
                let scale = (dist - 0.1) * config.handSensitivity;
                handData.distanceSmooth += (scale - handData.distanceSmooth) * 0.1;
            } else {
                handData.detected = false;
                handData.distanceSmooth += (0 - handData.distanceSmooth) * 0.05; // ç¼“æ…¢å½’é›¶
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onHandsResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });

        // --- åˆå§‹åŒ–é€»è¾‘ (ä¿®å¤é¡ºåºé—®é¢˜) ---
        // 1. å…ˆåˆå§‹åŒ–ç²’å­
        initMainParticles();

        // 2. ç„¶åå¯åŠ¨æ‘„åƒå¤´
        cameraUtils.start().catch(err => {
            console.warn("Camera Init Error:", err);
            document.getElementById('loader').innerText = "æœªæ£€æµ‹åˆ°æ‘„åƒå¤´ï¼Œå·²åˆ‡æ¢è‡³é¼ æ ‡æ¼”ç¤ºæ¨¡å¼";
        });

        // 3. æœ€ååˆå§‹åŒ– GUI (ç¡®ä¿ mainMaterial å­˜åœ¨)
        const gui = new GUI({ title: 'æ§åˆ¶é¢æ¿' });
        
        const planetNames = {};
        for(let k in planetData) planetNames[planetData[k].name] = k;
        
        gui.add(config, 'target', planetNames).name('é€‰æ‹©å¤©ä½“').onChange(val => {
            calculateTarget(val);
        });
        
        const f1 = gui.addFolder('æ•ˆæœè°ƒæ•´');
        f1.add(config, 'bloomStrength', 0, 3).name('è¾‰å…‰å¼ºåº¦').onChange(v => bloomPass.strength = v);
        f1.add(config, 'autoRotate').name('è‡ªåŠ¨æ—‹è½¬');
        // è¿™é‡Œçš„ mainMaterial è‚¯å®šå·²ç»å­˜åœ¨äº†
        f1.add(mainMaterial, 'size', 0.01, 0.1).name('ç²’å­å¤§å°');

        // --- åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            controls.autoRotate = config.autoRotate;
            controls.update();

            const positions = mainGeometry.attributes.position.array;
            const colors = mainGeometry.attributes.color.array;
            
            // åŸºç¡€è†¨èƒ€ç³»æ•° (æ‰‹åŠ¿æ§åˆ¶)
            const scale = 1.0 + handData.distanceSmooth;
            
            for(let i=0; i<config.particleCount; i++) {
                const ix = i*3; const iy = i*3+1; const iz = i*3+2;

                // è·å–ç›®æ ‡ä½ç½®å¹¶åº”ç”¨ç¼©æ”¾
                let tx = targetPositions[ix] * scale;
                let ty = targetPositions[iy] * scale;
                let tz = targetPositions[iz] * scale;

                // å¢åŠ å¾®å°çš„å‘¼å¸å™ªç‚¹ï¼Œè®©é™æ­¢çš„æ˜Ÿçƒçœ‹èµ·æ¥ä¹Ÿæœ‰ç”Ÿæ°”
                const n = noise.noise(targetPositions[ix]*0.1, targetPositions[iy]*0.1, time * 0.2) * 0.5;
                tx += n; ty += n; tz += n;

                // å¤ªé˜³ç‰¹æ®Šæ•ˆæœï¼šè¡¨é¢å‰§çƒˆç¿»æ»š
                if (config.target === 'sun') {
                    const sunFlare = Math.sin(time*2 + i)*0.5;
                    tx += targetPositions[ix] * 0.02 * sunFlare;
                    ty += targetPositions[iy] * 0.02 * sunFlare;
                    tz += targetPositions[iz] * 0.02 * sunFlare;
                }

                // å¹³æ»‘æ’å€¼ç§»åŠ¨
                positions[ix] += (tx - positions[ix]) * 0.08;
                positions[iy] += (ty - positions[iy]) * 0.08;
                positions[iz] += (tz - positions[iz]) * 0.08;
                
                // æ¢å¤é¢œè‰² (å¦‚æœæœ‰å¿…è¦çš„è¯ï¼Œè¿™é‡Œå¯ä»¥åšé¢œè‰²é—ªçƒé€»è¾‘)
                colors[ix] = baseColors[ix];
                colors[iy] = baseColors[iy];
                colors[iz] = baseColors[iz];
            }

            mainGeometry.attributes.position.needsUpdate = true;
            mainGeometry.attributes.color.needsUpdate = true;

            composer.render();
        }

        animate();

        // çª—å£è‡ªé€‚åº”
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        document.getElementById('fs-btn').addEventListener('click', () => {
             if (!document.fullscreenElement) document.body.requestFullscreen();
             else document.exitFullscreen();
        });
    </script>
</body>
</html>
