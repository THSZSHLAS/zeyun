<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜çº§æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ v2.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%); }
        /* æ‘„åƒå¤´é¢„è§ˆï¼Œç¨å¾®è°ƒå°ä¸€ç‚¹å¹¶æ”¾åœ¨è§’è½ */
        #video-input { position: absolute; bottom: 10px; left: 10px; width: 120px; height: 90px; transform: scaleX(-1); border-radius: 8px; opacity: 0.5; z-index: 2; border: 1px solid rgba(255,255,255,0.2); pointer-events: none; transition: opacity 0.3s; }
        #video-input.active { opacity: 0.9; }
        
        #fs-btn {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            background: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 15px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(5px);
            transition: all 0.3s; font-size: 14px;
        }
        #fs-btn:hover { background: white; color: black; }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00f2ff; font-size: 20px; z-index: 20; pointer-events: none;
            text-shadow: 0 0 15px rgba(0,242,255,0.5); letter-spacing: 2px;
        }
        /* Lil-gui æ ·å¼å¾®è°ƒ */
        .lil-gui { --width: 280px; --name-width: 40%; }
    </style>
</head>
<body>

    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <button id="fs-btn">â›¶ å…¨å±æ²‰æµ¸</button>
    <div id="loader">æ­£åœ¨åˆå§‹åŒ–è§†è§‰ä¸å¬è§‰æ ¸å¿ƒ...<br><span style="font-size:14px; opacity:0.7;">è¯·å…è®¸æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™</span></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
        import GUI from 'lil-gui';

        // --- é…ç½®ä¸çŠ¶æ€ ---
        const config = {
            mode: 'morph', // 'morph' (å˜å½¢æ¨¡å¼) æˆ– 'draw' (ç”»ç¬”æ¨¡å¼)
            shape: 'solidHeart',
            color: '#ff0066',
            particleCount: 8000, // å¢åŠ ç²’å­æ•°é‡ä»¥è·å¾—æ›´å¥½çš„å®å¿ƒæ•ˆæœ
            particleSize: 0.12,
            handSensitivity: 2.5,
            audioReactivity: false, // éŸ³é¢‘å“åº”å¼€å…³
            autoRotate: true,
            clearTrail: () => { if(trailSystem) trailSystem.clear(); } // æ¸…é™¤ç”»ç¬”æŒ‰é’®
        };

        let handData = {
            detected: false,
            distanceRaw: 0, // åŸå§‹è·ç¦»
            distanceSmooth: 0, // å¹³æ»‘åçš„è·ç¦» (ç”¨äºç¼©æ”¾)
            indexTipPos: new THREE.Vector3() // é£ŸæŒ‡å°– 3D ä½ç½®
        };
        
        let audioContext, analyser, dataArray;
        let audioLevelRaw = 0, audioLevelSmooth = 0;

        // --- Three.js åŸºç¡€åœºæ™¯ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // ä½¿ç”¨æ›´æ·±çš„è¿·é›¾å¢å¼ºç©ºé—´æ„Ÿ
        scene.fog = new THREE.FogExp2(0x000000, 0.015);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // æ€§èƒ½å¹³è¡¡
        // å¯ç”¨æ³›å…‰æ•ˆæœ (ç®€å•çš„ additive blending å®ç°ï¼Œä¸ä½¿ç”¨åå¤„ç†ä»¥ä¿æŒæ€§èƒ½)
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotateSpeed = 0.5;

        // --- ç³»ç»Ÿ 1: å˜å½¢ç²’å­ç¾¤ (Morphing System) ---
        let mainPoints, mainGeometry, mainMaterial;
        const initialPositions = [];
        const targetPositions = [];
        const noise = new ImprovedNoise();

        function initMainParticles() {
            if (mainPoints) scene.remove(mainPoints);
            initialPositions.length = 0;

            const posArray = new Float32Array(config.particleCount * 3);
            const colorsArray = new Float32Array(config.particleCount * 3);
            const baseColor = new THREE.Color(config.color);

            for (let i = 0; i < config.particleCount; i++) {
                // åˆå§‹åœ¨ä¸€ä¸ªå¤§çƒä½“å†…éšæœºåˆ†å¸ƒ
                const r = Math.random() * 40;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                initialPositions.push(x, y, z);
                posArray[i * 3] = x;
                posArray[i * 3 + 1] = y;
                posArray[i * 3 + 2] = z;

                // ç¨å¾®éšæœºåŒ–ä¸€ç‚¹é¢œè‰²
                let c = baseColor.clone();
                c.hsl(h => { h += (Math.random() - 0.5) * 0.1; return h; }); // è‰²ç›¸å¾®è°ƒ
                colorsArray[i * 3] = c.r;
                colorsArray[i * 3 + 1] = c.g;
                colorsArray[i * 3 + 2] = c.b;
            }

            mainGeometry = new THREE.BufferGeometry();
            mainGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            mainGeometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));

            // ä½¿ç”¨è‡ªå®šä¹‰æè´¨ä»¥æ”¯æŒé¡¶ç‚¹é¢œè‰²å’Œæ›´å¥½çš„é€æ˜åº¦
            mainMaterial = new THREE.PointsMaterial({
                size: config.particleSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: createParticleTexture() // ä½¿ç”¨åœ†å½¢çº¹ç†è®©ç²’å­æ›´æŸ”å’Œ
            });

            mainPoints = new THREE.Points(mainGeometry, mainMaterial);
            scene.add(mainPoints);
            calculateTargetShape(config.shape);
        }
        
        // åˆ›å»ºæŸ”å’Œçš„åœ†å½¢ç²’å­çº¹ç†
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- æ ¸å¿ƒç®—æ³•ï¼šå½¢çŠ¶è®¡ç®— (åŒ…å«å®å¿ƒçˆ±å¿ƒ) ---
        function calculateTargetShape(shapeType) {
            targetPositions.length = 0;
            let x, y, z;

            for (let i = 0; i < config.particleCount; i++) {
                
                if (shapeType === 'solidHeart') {
                    // --- å®å¿ƒçˆ±å¿ƒç®—æ³• (ä½“ç§¯é‡‡æ ·/æ‹’ç»é‡‡æ ·) ---
                    // è¿™é‡Œçš„å…³é”®æ˜¯ä¸æ–­åœ¨ä¸€ä¸ªç›’å­å†…éšæœºå–ç‚¹ï¼Œ
                    // ç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³çˆ±å¿ƒå†…éƒ¨æ•°å­¦å…¬å¼çš„ç‚¹ã€‚
                    while (true) {
                        // åœ¨ä¸€ä¸ªåŒ…å›´ç›’å†…éšæœºå–ç‚¹
                        x = (Math.random() - 0.5) * 30;
                        y = (Math.random() - 0.5) * 30;
                        z = (Math.random() - 0.5) * 15; 

                        x /= 10; y /= 10; z /= 10; // ç¼©æ”¾ä»¥ä¾¿è®¡ç®—

                        // çˆ±å¿ƒéšå‡½æ•°å…¬å¼ (Taubin's heart surface çš„å˜ä½“)
                        const a = x * x + (9/4) * y * y + z * z - 1;
                        // å¦‚æœæ»¡è¶³æ¡ä»¶ï¼Œè¯´æ˜ç‚¹åœ¨çˆ±å¿ƒå†…éƒ¨
                        if (a * a * a - x * x * z * z * z - (9/80) * y * y * z * z * z < 0) {
                            x *= 10; y *= 10; z *= 10; // è¿˜åŸç¼©æ”¾
                            y += 3; // å‘ä¸‹å¹³ç§»ä¸€ç‚¹ä½¿å…¶å±…ä¸­
                            break; // æ‰¾åˆ°ç‚¹ï¼Œè·³å‡ºå¾ªç¯
                        }
                    }
                } 
                else if (shapeType === 'sphere') {
                    // å®å¿ƒçƒä½“
                    const r = 12 * Math.cbrt(Math.random()); //ä½¿ç”¨ç«‹æ–¹æ ¹åˆ†å¸ƒç¡®ä¿å†…éƒ¨å‡åŒ€
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }
                else if (shapeType === 'torusKnot') {
                    // ç¯é¢ç»“ (å¤æ‚å‡ ä½•)
                    const t = (i / config.particleCount) * Math.PI * 2 * 3; // ç¯ç»•3åœˆ
                    const p = 2, q = 3; // ç»“çš„å‚æ•°
                    const r = 8 + 3 * Math.cos(q * t); // åŠå¾„å˜åŒ–
                    x = r * Math.cos(p * t);
                    y = r * Math.sin(p * t);
                    z = 6 * Math.sin(q * t);
                    
                    // åŠ ä¸€ç‚¹éšæœºæŠ–åŠ¨å¢åŠ ä½“ç§¯æ„Ÿ
                    x += (Math.random()-0.5)*1.5;
                    y += (Math.random()-0.5)*1.5;
                    z += (Math.random()-0.5)*1.5;
                }
                else if (shapeType === 'dna') {
                    // åŒèºæ—‹ DNA
                    const t = (i / config.particleCount) * Math.PI * 10; // é«˜åº¦å‚æ•°
                    const radius = 6;
                    const height = 30;
                    const yPos = (i / config.particleCount - 0.5) * height;
                    
                    // å°†ç²’å­åˆ†æˆä¸¤ç»„ï¼Œå½¢æˆåŒé“¾
                    const offset = i % 2 === 0 ? 0 : Math.PI; 
                    x = radius * Math.cos(t + offset);
                    z = radius * Math.sin(t + offset);
                    y = yPos;

                    // éšæœºå¡«å……ä¸€ç‚¹åœ¨æ¢¯çº§ä¸­é—´
                    if (Math.random() > 0.8) {
                         x *= Math.random(); z *= Math.random();
                    }
                }

                targetPositions.push(x, y, z);
            }
        }

        // --- ç³»ç»Ÿ 2: ç”»ç¬”è½¨è¿¹ç³»ç»Ÿ (Trail System) ---
        const trailSystem = {
            maxParticles: 3000,
            geometry: null,
            material: null,
            points: null,
            positions: null,
            opacities: null,
            headIndex: 0, // å½“å‰å†™å…¥ä½ç½®çš„æŒ‡é’ˆ

            init: function() {
                this.positions = new Float32Array(this.maxParticles * 3);
                this.opacities = new Float32Array(this.maxParticles);
                // åˆå§‹åŒ–åœ¨å±å¹•å¤–
                for(let i=0; i<this.maxParticles; i++) this.positions[i*3 + 1] = 9999;
                
                this.geometry = new THREE.BufferGeometry();
                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('opacityAttr', new THREE.BufferAttribute(this.opacities, 1));

                // è‡ªå®šä¹‰ Shader æè´¨ç”¨äºå¤„ç†å•ä¸ªç²’å­çš„é€æ˜åº¦è¡°å‡
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: new THREE.Color(config.color) },
                        pointTexture: { value: createParticleTexture() }
                    },
                    vertexShader: `
                        attribute float opacityAttr;
                        varying float vOpacity;
                        void main() {
                            vOpacity = opacityAttr;
                            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                            gl_PointSize = 15.0 * ( 1.0 / - mvPosition.z ) * vOpacity; // å¤§å°éšé€æ˜åº¦å˜åŒ–
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 color;
                        uniform sampler2D pointTexture;
                        varying float vOpacity;
                        void main() {
                            if (vOpacity <= 0.01) discard;
                            gl_FragColor = vec4( color, vOpacity );
                            gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.points = new THREE.Points(this.geometry, this.material);
                scene.add(this.points);
                this.points.visible = false; // åˆå§‹éšè—
            },

            update: function(targetPos, isDrawing) {
                if (!this.points.visible) return;

                // è¡°å‡æ‰€æœ‰ç²’å­çš„é€æ˜åº¦
                for (let i = 0; i < this.maxParticles; i++) {
                    this.opacities[i] *= 0.96; // è¡°å‡é€Ÿåº¦
                }

                // å¦‚æœåœ¨ç»˜ç”»ï¼Œæ·»åŠ æ–°ç²’å­åˆ°å¤´éƒ¨
                if (isDrawing && targetPos) {
                    this.headIndex = (this.headIndex + 1) % this.maxParticles;
                    const idx = this.headIndex * 3;
                    this.positions[idx] = targetPos.x;
                    this.positions[idx + 1] = targetPos.y;
                    this.positions[idx + 2] = targetPos.z;
                    this.opacities[this.headIndex] = 1.0; // æ–°ç²’å­å®Œå…¨ä¸é€æ˜
                }

                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.opacityAttr.needsUpdate = true;
            },
            
            clear: function() {
                 for(let i=0; i<this.maxParticles; i++) this.opacities[i] = 0;
                 this.geometry.attributes.opacityAttr.needsUpdate = true;
            }
        };

        // --- éŸ³é¢‘å¤„ç† (å¯é€‰) ---
        async function setupAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                console.log("Audio initialized");
            } catch (e) {
                console.warn("Audio init failed (permission denied or ignored):", e);
                config.audioReactivity = false; // å¼ºåˆ¶å…³é—­
                if(guiAudioCtrl) guiAudioCtrl.disable();
            }
        }

        // --- MediaPipe å¤„ç† ---
        const videoElement = document.getElementById('video-input');
        
        function onHandsResults(results) {
            document.getElementById('loader').style.display = 'none';
            videoElement.classList.add('active');

            handData.detected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;

            if (handData.detected) {
                const hands = results.multiHandLandmarks;

                // --- æ¨¡å¼ 1: åŒæ‰‹è·ç¦»è®¡ç®— (ç”¨äºå˜å½¢æ¨¡å¼ç¼©æ”¾) ---
                let newDistance = 0;
                if (hands.length === 2) {
                    // åŒæ‰‹è…•é—´è·
                    const h1 = hands[0][0]; const h2 = hands[1][0];
                    newDistance = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                } else if (hands.length === 1) {
                    // å•æ‰‹æ‹‡æŒ‡é£ŸæŒ‡é—´è·
                    const h1 = hands[0][4]; const h2 = hands[0][8];
                    newDistance = Math.hypot(h1.x - h2.x, h1.y - h2.y) * 2.0; // æ”¾å¤§å•æ‰‹æ•ˆæœ
                }
                // æ˜ å°„å’Œè¿‡æ»¤ (è®¾ç½®æ­»åŒºä»¥å‡å°‘æŠ–åŠ¨)
                let targetRaw = Math.max(0, (newDistance - 0.1) * config.handSensitivity);
                handData.distanceRaw = targetRaw;

                // --- æ¨¡å¼ 2: é£ŸæŒ‡å°–è¿½è¸ª (ç”¨äºç”»ç¬”æ¨¡å¼) ---
                // è·å–ç¬¬ä¸€åªæ‰‹çš„é£ŸæŒ‡å°– ( landmark 8 )
                const indexTip2D = hands[0][8];
                // å°† 2D å±å¹•åæ ‡è½¬æ¢ä¸º 3D ä¸–ç•Œåæ ‡
                // æˆ‘ä»¬éœ€è¦å°†ç‚¹æŠ•å½±åˆ°æ‘„åƒæœºå‰æ–¹çš„ä¸€ä¸ªå¹³é¢ä¸Š
                const vec = new THREE.Vector3();
                vec.set((indexTip2D.x * 2) - 1, -(indexTip2D.y * 2) + 1, 0.5); // z=0.5 åœ¨ NDC ä¸­
                vec.unproject(camera);
                vec.sub(camera.position).normalize();
                // å°†å°„çº¿æŠ•å°„åˆ° Z=0 å¹³é¢é™„è¿‘ (è·ç¦»æ‘„åƒæœº20ä¸ªå•ä½çš„ä½ç½®)
                const distanceToPlane = -camera.position.z / vec.z; 
                const drawDepth = 20; // åœ¨è·ç¦»æ‘„åƒæœº 20 çš„å¹³é¢ä¸Šç»˜ç”»
                vec.multiplyScalar(drawDepth);
                const finalPos = camera.position.clone().add(vec);
                
                // å¹³æ»‘ç§»åŠ¨æŒ‡å°–ä½ç½®
                handData.indexTipPos.lerp(finalPos, 0.2);
            } else {
                handData.distanceRaw = 0; // æ— æ‰‹æ—¶å¤ä½
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onHandsResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        

        // --- UI åˆå§‹åŒ– ---
        const gui = new GUI({ title: 'æ§åˆ¶ç»ˆç«¯ v2' });
        gui.add(config, 'mode', { 'æ‰‹åŠ¿å˜å½¢ (Morph)': 'morph', 'è™šç©ºç”»ç¬” (Draw)': 'draw' })
           .name('äº¤äº’æ¨¡å¼ ğŸ®')
           .onChange(mode => {
               mainPoints.visible = (mode === 'morph');
               trailSystem.points.visible = (mode === 'draw');
               if (mode === 'draw') trailSystem.clear();
           });

        const folderMorph = gui.addFolder('å˜å½¢è®¾ç½®').close();
        folderMorph.add(config, 'shape', { 'å®å¿ƒçˆ±å¿ƒ': 'solidHeart', 'ç¯é¢ç»“': 'torusKnot', 'DNAåŒèºæ—‹': 'dna', 'å®å¿ƒçƒä½“': 'sphere' }).name('ç›®æ ‡å½¢çŠ¶').onChange(val => calculateTargetShape(val));
        folderMorph.addColor(config, 'color').name('ä¸»é¢˜é¢œè‰²').onChange(val => {
             const c = new THREE.Color(val);
             mainMaterial.color.set(c);
             trailSystem.material.uniforms.color.value.set(c);
             // é‡æ–°ç”Ÿæˆå¸¦é¢œè‰²å˜åŒ–çš„ç²’å­
             initMainParticles();
        });
        folderMorph.add(config, 'handSensitivity', 1.0, 5.0).name('æ‰‹åŠ¿æ•æ„Ÿåº¦');
        
        const guiAudioCtrl = folderMorph.add(config, 'audioReactivity').name('ğŸµ éŸ³é¢‘å¾‹åŠ¨').onChange(v => {
            if (v && !audioContext) setupAudio();
        });

        const folderDraw = gui.addFolder('ç”»ç¬”è®¾ç½®').close();
        folderDraw.add(config, 'clearTrail').name('æ¸…é™¤ç¬”è¿¹ ğŸ—‘ï¸');

        gui.add(config, 'autoRotate').name('è‡ªåŠ¨æ—‹è½¬åœºæ™¯');
        gui.close(); // é»˜è®¤æŠ˜å é¢æ¿

        // --- ä¸»åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const delta = clock.getDelta();

            controls.autoRotate = config.autoRotate;
            controls.update();

            // --- æ•°æ®å¹³æ»‘å¤„ç† ---
            // å¹³æ»‘æ‰‹åŠ¿è·ç¦» (Lerp)
            handData.distanceSmooth += (handData.distanceRaw - handData.distanceSmooth) * 0.1;
            
            // å¤„ç†éŸ³é¢‘æ•°æ®
            if (config.audioReactivity && analyser) {
                analyser.getByteFrequencyData(dataArray);
                // è®¡ç®—å¹³å‡éŸ³é‡
                let sum = 0;
                for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
                audioLevelRaw = sum / dataArray.length / 256; // å½’ä¸€åŒ– 0.0-1.0
                // å¹³æ»‘éŸ³é‡
                audioLevelSmooth += (audioLevelRaw - audioLevelSmooth) * 0.2;
            } else {
                audioLevelSmooth = 0;
            }


            // --- æ¨¡å¼åˆ†æ”¯æ¸²æŸ“ ---
            if (config.mode === 'morph') {
                // === å˜å½¢æ¨¡å¼é€»è¾‘ ===
                const positions = mainGeometry.attributes.position.array;
                // åŸºç¡€ç¼©æ”¾ + æ‰‹åŠ¿å½±å“ + éŸ³é¢‘å½±å“
                let baseScale = 1.0 + handData.distanceSmooth * 1.2;
                let audioScaleBump = 1.0 + audioLevelSmooth * 0.8; // éŸ³é¢‘å¸¦æ¥çš„é¢å¤–ç¬é—´æ”¾å¤§

                for (let i = 0; i < config.particleCount; i++) {
                    const ix = i * 3; const iy = i * 3 + 1; const iz = i * 3 + 2;
                    
                    // è·å–ç›®æ ‡ä½ç½®å¹¶åº”ç”¨ç¼©æ”¾
                    let tx = targetPositions[ix] * baseScale * audioScaleBump;
                    let ty = targetPositions[iy] * baseScale * audioScaleBump;
                    let tz = targetPositions[iz] * baseScale * audioScaleBump;

                    // æ·»åŠ åŸºäºå™ªéŸ³çš„æœ‰æœºæ¼‚æµ®æ„Ÿ (å‘¼å¸æ•ˆæœ)
                    // ä½¿ç”¨ 4D å™ªéŸ³ (x, y, z, time) è®©æ¯ä¸ªç‚¹æœ‰ç‹¬ç‰¹çš„è¿åŠ¨è½¨è¿¹
                    const nScale = 0.05;
                    const nSpeed = time * 0.5;
                    // éŸ³é¢‘è¶Šå¼ºï¼Œå™ªç‚¹æŠ–åŠ¨è¶Šå‰§çƒˆ
                    const noiseIntensity = 0.3 + audioLevelSmooth * 1.5; 
                    tx += noise.noise(positions[ix]*nScale, positions[iy]*nScale, positions[iz]*nScale + nSpeed) * noiseIntensity;
                    ty += noise.noise(positions[ix]*nScale + 100, positions[iy]*nScale, positions[iz]*nScale + nSpeed) * noiseIntensity;
                    tz += noise.noise(positions[ix]*nScale + 200, positions[iy]*nScale, positions[iz]*nScale + nSpeed) * noiseIntensity;
                    
                    // å¹³æ»‘ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½® (Lerp)
                    positions[ix] += (tx - positions[ix]) * 0.06;
                    positions[iy] += (ty - positions[iy]) * 0.06;
                    positions[iz] += (tz - positions[iz]) * 0.06;
                }
                mainGeometry.attributes.position.needsUpdate = true;
                // åŠ¨æ€è°ƒæ•´ç²’å­å¤§å°åŸºäºéŸ³é¢‘
                mainMaterial.size = config.particleSize * (1 + audioLevelSmooth * 1.5);

            } else {
                // === ç”»ç¬”æ¨¡å¼é€»è¾‘ ===
                // åªæœ‰å½“æ£€æµ‹åˆ°æ‰‹æ—¶æ‰è¿›è¡Œç»˜åˆ¶
                trailSystem.update(handData.indexTipPos, handData.detected);
            }

            renderer.render(scene, camera);
        }

        // --- åˆå§‹åŒ–ä¸äº‹ä»¶ç›‘å¬ ---
        initMainParticles();
        trailSystem.init();
        cameraUtils.start().catch(e => { console.error("Camera failed:", e); document.getElementById('loader').textContent = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•æˆ–æ£€æŸ¥æƒé™ã€‚"; });
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('fs-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) document.body.requestFullscreen().catch(err => alert("æ— æ³•è¿›å…¥å…¨å±"));
            else document.exitFullscreen();
        });

    </script>
</body>
</html>
