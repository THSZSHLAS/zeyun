<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ˜Ÿæ ¸æ™¶ä½“ - ç§©åºä¹‹ç¾ v12</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* æ‘„åƒå¤´é¢„è§ˆï¼šæç®€çº¿æ¡æ¡† */
        #video-input { 
            position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px; 
            transform: scaleX(-1); opacity: 0.3; z-index: 2; 
            border: 2px solid #4facfe; border-radius: 4px;
            pointer-events: none; mix-blend-mode: screen;
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.5);
        }
        
        /* é¡¶éƒ¨æ ‡é¢˜ */
        #title-overlay {
            position: absolute; top: 20px; left: 0; width: 100%; text-align: center;
            color: #4facfe; font-size: 14px; z-index: 5; pointer-events: none;
            letter-spacing: 6px; text-transform: uppercase;
            text-shadow: 0 0 10px rgba(79, 172, 254, 0.8);
        }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 14px; z-index: 20; pointer-events: none;
            letter-spacing: 4px; text-transform: uppercase; border: 1px solid #4facfe;
            padding: 15px 30px; background: rgba(0,0,0,0.8);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.3);
        }

        /* å®šåˆ¶ GUI */
        .lil-gui { 
            --background-color: rgba(5, 5, 10, 0.9); 
            --text-color: #eee; 
            --title-background-color: #0a1525;
            --widget-color: #222;
            --focus-color: #4facfe;
            --width: 240px;
            border: 1px solid #4facfe;
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.2);
        }
        .lil-gui .title { color: #4facfe; font-weight: bold; }
    </style>
</head>
<body>

    <div id="title-overlay">Holographic Crystal System</div>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <div id="loader">Initializing System...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // --- æ ¸å¿ƒé…ç½® ---
        const config = {
            count: 5000,          // ç²’å­æ•°é‡é€‚ä¸­ï¼Œä¿è¯å¤§å°ºå¯¸ä¸å¡é¡¿
            voxelSize: 0.45,      // ğŸ”¥ ç²’å­éå¸¸å¤§ï¼æ¸…æ™°å¯è§çš„æ™¶ä½“
            target: 'earth',      // é»˜è®¤åœ°çƒ
            bloomStrength: 1.8,   // å¼ºçƒˆçš„èµ›åšè¾‰å…‰
            bloomRadius: 0.6,
            handZoomSpeed: 0.1,
            handRotateSpeed: 3.0,
            autoRotate: true
        };

        // --- é¢œè‰²è°ƒè‰²æ¿ (åŸºäºä½ ç»™çš„ rgba(79, 172, 254)) ---
        const colors = {
            mainBlue: new THREE.Color(0x4facfe), // ä½ çš„ä¸»è‰²
            cyan: new THREE.Color(0x00f2fe),     // é’è‰²é«˜äº®
            purple: new THREE.Color(0x8e44ad),   // é“¶æ²³ç³»ç‚¹ç¼€
            gold: new THREE.Color(0xffd700),     // å¤ªé˜³/åœŸæ˜Ÿ
            white: new THREE.Color(0xffffff)     // æ ¸å¿ƒé«˜äº®
        };

        // --- åœºæ™¯æ­å»º ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020205); // ææ·±è“é»‘èƒŒæ™¯
        scene.fog = new THREE.FogExp2(0x020205, 0.02); // é›¾æ°”å¢å¼ºæ™¯æ·±

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 35; // é»˜è®¤è·ç¦»

        const renderer = new THREE.WebGLRenderer({ antialias: false }); // å…³é—­æŠ—é”¯é½¿ä»¥è·å¾—é”åˆ©çš„ä½“ç´ æ„Ÿ
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // --- åæœŸå¤„ç† (Bloom è¾‰å…‰) ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = config.bloomStrength;
        bloomPass.radius = config.bloomRadius;
        composer.addPass(bloomPass);

        // --- æ ¸å¿ƒï¼šInstancedMesh (å®ä½“æ–¹å—ç²’å­) ---
        // ä½¿ç”¨ BoxGeometry (ç«‹æ–¹ä½“) 
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff }); // é¢œè‰²ç”±å®ä¾‹æ§åˆ¶
        const mesh = new THREE.InstancedMesh(geometry, material, config.count);
        scene.add(mesh);

        // æ•°æ®å­˜å‚¨
        const dummy = new THREE.Object3D();
        const positions = [];       // å½“å‰ä½ç½®
        const targetPositions = []; // ç›®æ ‡ä½ç½®
        const currentColors = [];   // å½“å‰é¢œè‰²
        const targetColors = [];    // ç›®æ ‡é¢œè‰²

        // åˆå§‹åŒ–æ•°ç»„
        for(let i=0; i<config.count; i++) {
            positions.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
            targetPositions.push(0,0,0);
            currentColors.push(0,0,1);
            targetColors.push(0,0,1);
        }

        // --- å½¢çŠ¶ç”Ÿæˆç®—æ³• ---
        // ç®€å•çš„å™ªå£°æ¨¡æ‹Ÿ
        function simpleNoise(x, y, z) {
            return Math.sin(x*10 + Math.cos(y*12 + z*15)) * 0.5 + 0.5;
        }

        function calculateLayout(type) {
            const rBase = 12; // åŸºç¡€åŠå¾„

            for (let i = 0; i < config.count; i++) {
                let x, y, z;
                let c = colors.mainBlue;
                
                // å‡åŒ€çƒä½“åˆ†å¸ƒ
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                if (type === 'sun') {
                    // å¤ªé˜³ï¼šæ ¸å¿ƒ + çˆ†å‘
                    const r = rBase * (0.6 + Math.random() * 0.4);
                    // éšæœºå–·å°„
                    const spike = Math.random() > 0.9 ? 1.5 : 1.0;
                    x = r * spike * Math.sin(phi) * Math.cos(theta);
                    y = r * spike * Math.sin(phi) * Math.sin(theta);
                    z = r * spike * Math.cos(phi);
                    
                    // é¢œè‰²ï¼šé‡‘/çº¢/ç™½
                    const mix = Math.random();
                    if(mix > 0.7) c = colors.white;
                    else if(mix > 0.3) c = colors.gold;
                    else c = new THREE.Color(0xff4500); // çº¢æ©™

                } else if (type === 'earth') {
                    // åœ°çƒï¼šé™†åœ°ä¸æµ·æ´‹
                    const r = rBase;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    
                    const noiseVal = simpleNoise(x*0.1, y*0.1, z*0.1);
                    if (noiseVal > 0.6) {
                        c = new THREE.Color(0x22aa22); // ç»¿åœ°
                        x *= 1.02; y *= 1.02; z *= 1.02; // é™†åœ°å‡¸èµ·
                    } else {
                        c = colors.mainBlue.clone().lerp(new THREE.Color(0x000033), Math.random()*0.5); // æ·±è“æµ·
                    }

                } else if (type === 'saturn') {
                    // åœŸæ˜Ÿï¼šçƒä½“ + ç¯
                    if (i < config.count * 0.4) {
                        // æœ¬ä½“
                        const r = rBase * 0.8;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                        c = colors.gold.clone().multiplyScalar(0.8);
                    } else {
                        // ç¯ (æ‰å¹³åŒ–)
                        const r = rBase * (1.2 + Math.random());
                        const angle = Math.random() * Math.PI * 2;
                        x = r * Math.cos(angle);
                        z = r * Math.sin(angle);
                        y = (Math.random()-0.5) * 0.5; // æè–„
                        c = colors.mainBlue.clone().lerp(colors.white, Math.random());
                    }

                } else if (type === 'galaxy') {
                    // é“¶æ²³ï¼šæ—‹è‡‚
                    const arm = i % 3;
                    const r = Math.random() * rBase * 1.5;
                    const angle = r * 0.5 + (arm * Math.PI * 2 / 3);
                    x = r * Math.cos(angle) + (Math.random()-0.5)*2;
                    z = r * Math.sin(angle) + (Math.random()-0.5)*2;
                    y = (Math.random()-0.5) * (15 - r*0.5); // ä¸­å¿ƒåšè¾¹ç¼˜è–„
                    
                    const dist = r / (rBase*1.5);
                    if (dist < 0.2) c = colors.white;
                    else if (dist < 0.6) c = colors.purple;
                    else c = colors.mainBlue;
                }

                targetPositions[i*3] = x; targetPositions[i*3+1] = y; targetPositions[i*3+2] = z;
                targetColors[i*3] = c.r; targetColors[i*3+1] = c.g; targetColors[i*3+2] = c.b;
            }
        }

        // åˆå§‹åŠ è½½
        calculateLayout(config.target);

        // --- æ‰‹åŠ¿æ§åˆ¶é€»è¾‘ ---
        let targetZoom = 35; 
        let targetRotY = 0;
        
        const videoElement = document.getElementById('video-input');
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hands = results.multiHandLandmarks;
                
                // 1. ç¼©æ”¾é€»è¾‘
                let pinchDist = 0;
                let handCenterX = 0.5;

                if (hands.length === 2) {
                    // åŒæ‰‹è·ç¦»
                    const h1 = hands[0][0]; const h2 = hands[1][0];
                    pinchDist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                    handCenterX = (h1.x + h2.x) / 2;
                } else {
                    // å•æ‰‹å¼ å¼€è·ç¦»
                    const thumb = hands[0][4]; const pinky = hands[0][20];
                    pinchDist = Math.hypot(thumb.x - pinky.x, thumb.y - pinky.y) * 2;
                    handCenterX = hands[0][9].x;
                }

                // æ˜ å°„ç¼©æ”¾ (è·ç¦»è¶Šå¤§ -> æ‘„åƒæœºè¶Šè¿‘)
                // pinchDist 0.1 ~ 0.8
                const zoomFactor = 1.0 - Math.min(Math.max(pinchDist, 0.1), 0.8);
                targetZoom = 15 + zoomFactor * 50;

                // 2. æ—‹è½¬é€»è¾‘ (åŸºäºæ‰‹çš„ä½ç½®)
                targetRotY += (handCenterX - 0.5) * config.handRotateSpeed * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });
        cameraUtils.start();

        // --- GUI ---
        const gui = new GUI({ title: 'CONTROL PANEL' });
        const shapes = { 'ğŸŒ Earth': 'earth', 'â˜€ï¸ Sun': 'sun', 'ğŸª Saturn': 'saturn', 'ğŸŒŒ Galaxy': 'galaxy' };
        gui.add(config, 'target', shapes).name('System Target').onChange(v => calculateLayout(v));
        gui.add(config, 'voxelSize', 0.1, 1.0).name('Crystal Size'); // æ§åˆ¶ç²’å­å¤§å°
        gui.add(config, 'bloomStrength', 0, 3).name('Neon Glow').onChange(v => bloomPass.strength = v);
        gui.add(config, 'autoRotate').name('Auto Spin');

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. æ‘„åƒæœºè·Ÿéšæ‰‹åŠ¿
            camera.position.z += (targetZoom - camera.position.z) * 0.05;
            
            // 2. æ•´ä½“æ—‹è½¬
            mesh.rotation.y += (targetRotY - mesh.rotation.y) * 0.05;
            if(config.autoRotate) mesh.rotation.y += 0.002;
            mesh.rotation.x = Math.sin(Date.now()*0.0005) * 0.1; // è½»å¾®æµ®åŠ¨

            // 3. ç²’å­æ’å€¼æ›´æ–°
            const time = Date.now() * 0.001;
            const tempColor = new THREE.Color();
            
            for (let i = 0; i < config.count; i++) {
                const ix = i * 3; const iy = i * 3 + 1; const iz = i * 3 + 2;
                
                // ä½ç½® Lerp
                positions[ix] += (targetPositions[ix] - positions[ix]) * 0.08;
                positions[iy] += (targetPositions[iy] - positions[iy]) * 0.08;
                positions[iz] += (targetPositions[iz] - positions[iz]) * 0.08;

                // é¢œè‰² Lerp
                currentColors[ix] += (targetColors[ix] - currentColors[ix]) * 0.05;
                currentColors[iy] += (targetColors[iy] - currentColors[iy]) * 0.05;
                currentColors[iz] += (targetColors[iz] - currentColors[iz]) * 0.05;

                // è®¾ç½®çŸ©é˜µ
                dummy.position.set(positions[ix], positions[iy], positions[iz]);
                
                // å‘¼å¸æ•ˆæœï¼šæ ¹æ®ä½ç½®å’Œæ—¶é—´åŠ¨æ€è°ƒæ•´å¤§å°
                const breath = 0.8 + 0.3 * Math.sin(time * 3 + i * 0.05);
                const scale = config.voxelSize * breath;
                dummy.scale.set(scale, scale, scale);
                
                // è‡ªè½¬ï¼šæ¯ä¸ªæ–¹å—è‡ªå·±ä¹Ÿåœ¨è½¬
                dummy.rotation.set(time + i, time * 0.5 + i, 0);

                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
                
                // è®¾ç½®é¢œè‰²
                tempColor.setRGB(currentColors[ix], currentColors[iy], currentColors[iz]);
                mesh.setColorAt(i, tempColor);
            }
            mesh.instanceMatrix.needsUpdate = true;
            mesh.instanceColor.needsUpdate = true;

            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
