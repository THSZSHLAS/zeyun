<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holo-Engine V4 | V8 & Galaxy</title>
    <link rel="icon" href="data:;base64,=">
    
    <style>
        /* --- 基础样式 --- */
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        
        /* --- UI 层 --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* --- 视频操控台 --- */
        #camera-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 280px;
            height: 210px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 10, 20, 0.85);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
            backdrop-filter: blur(5px);
            pointer-events: auto;
            transition: transform 0.3s;
        }
        #camera-container:hover { transform: scale(1.02); border-color: #00ffff; }
        
        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.6;
        }

        .hud-overlay {
            position: absolute;
            top: 10px; left: 10px;
            color: #00ffff;
            font-size: 11px;
            letter-spacing: 1px;
            text-shadow: 0 0 2px rgba(0,255,255,0.5);
        }

        .status-dot {
            display: inline-block;
            width: 6px; height: 6px;
            background-color: #333;
            border-radius: 50%;
            margin-right: 6px;
            box-shadow: 0 0 0 2px #555;
            transition: all 0.3s;
        }
        .status-dot.active {
            background-color: #00ff00;
            box-shadow: 0 0 5px #00ff00, 0 0 0 2px rgba(0,255,0,0.3);
        }

        /* --- 加载遮罩 --- */
        #loader {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ffff;
            z-index: 100;
            transition: opacity 1s;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 2px solid #003333;
            border-top: 2px solid #00ffff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* GUI 样式调整 */
        .lil-gui { 
            --background-color: rgba(0, 10, 20, 0.9);
            --text-color: #e0faff;
            --title-background-color: #004444;
            --widget-color: #006666;
            font-family: 'Courier New', monospace !important;
            font-size: 11px;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/three@0.160.0/examples/jsm/libs/lil-gui.module.min.js"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loading-text">SYSTEM INITIALIZING...</div>
    </div>

    <div id="ui-layer">
        <div id="camera-container">
            <video id="input-video" playsinline></video>
            <div class="hud-overlay">
                <span id="status-dot" class="status-dot"></span>
                <span id="status-text">SYSTEM OFFLINE</span>
                <br>
                <span id="gesture-data" style="opacity: 0.6;">WAITING...</span>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // ==========================================
        // 1. 配置与状态
        // ==========================================
        const config = {
            model: 'V8 Engine', // 默认模型
            lineColor: '#00ffff',
            particleColor: '#0088ff',
            accentColor: '#ff0055', // V8 点火颜色
            particleSize: 0.3,
            bloomStrength: 1.0,
            inertiaDamping: 0.96,
            sensitivity: 0.15,
            autoRotate: true
        };

        const state = {
            handDetected: false,
            mode: 'IDLE',
            targetRotation: { x: 0.5, y: 0.5 }, // 初始角度稍微侧一点，好看
            currentRotation: { x: 0.5, y: 0.5 },
            velocity: { x: 0, y: 0 },
            lastHandPos: { x: 0, y: 0 },
            targetZoom: 35,
            currentZoom: 35,
        };

        // ==========================================
        // 2. 场景 & 渲染
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020202, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = config.bloomStrength;
        bloomPass.radius = 0.4;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // ==========================================
        // 3. 材质与资源
        // ==========================================
        // 生成柔和粒子纹理
        function createGlowTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.4,'rgba(255,255,255,0.5)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }
        
        const matLine = new THREE.LineBasicMaterial({ color: config.lineColor, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending });
        const matPart = new THREE.PointsMaterial({ color: config.particleColor, size: config.particleSize, map: createGlowTexture(), transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false });
        const matAccent = new THREE.PointsMaterial({ color: config.accentColor, size: config.particleSize*1.5, map: createGlowTexture(), transparent: true, opacity: 1, blending: THREE.AdditiveBlending, depthWrite: false });

        // 通用构建函数：将几何体转换为 线框+粒子
        function makeHoloObj(geometry, pChance = 0.5, matP = matPart) {
            const g = new THREE.Group();
            g.add(new THREE.LineSegments(new THREE.WireframeGeometry(geometry), matLine));
            
            const pGeo = new THREE.BufferGeometry();
            const pos = geometry.attributes.position;
            const pts = [];
            for(let i=0; i<pos.count; i++) if(Math.random()<pChance) pts.push(pos.getX(i),pos.getY(i),pos.getZ(i));
            pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pts,3));
            g.add(new THREE.Points(pGeo, matP));
            return g;
        }

        // ==========================================
        // 4. 模型库 (Model Library)
        // ==========================================
        let currentGroup = new THREE.Group();
        let animatables = []; // 存储需要每帧更新动画的部件 (如活塞)
        scene.add(currentGroup);

        // --- Model 1: V8 Engine (机械V8) ---
        function buildV8() {
            const group = new THREE.Group();
            animatables = []; // 清空动画列表

            const cylRadius = 1.2;
            const cylHeight = 4;
            const spacing = 3;
            
            // 构建 8 个气缸
            for(let side = 0; side < 2; side++) {
                const sideGroup = new THREE.Group();
                // V型夹角 (左右各倾斜45度)
                const angle = (side === 0 ? 1 : -1) * (Math.PI / 4);
                sideGroup.rotation.z = angle;

                for(let i = 0; i < 4; i++) {
                    const zPos = (i - 1.5) * spacing;
                    
                    // 1. 气缸外壳 (Cylinder Block)
                    const cylGeo = new THREE.CylinderGeometry(cylRadius, cylRadius, cylHeight, 16, 1, true);
                    const cylMesh = makeHoloObj(cylGeo, 0.3);
                    cylMesh.position.set(0, cylHeight/2 + 1, zPos);
                    sideGroup.add(cylMesh);

                    // 2. 活塞 (Piston) - 这是需要动的
                    const pistonGeo = new THREE.CylinderGeometry(cylRadius*0.8, cylRadius*0.8, cylHeight*0.8, 16);
                    const pistonMesh = makeHoloObj(pistonGeo, 0.8, matAccent); // 使用强调色
                    
                    // 将活塞存入动画列表
                    // offset 用于错开点火时间
                    animatables.push({
                        mesh: pistonMesh,
                        type: 'piston',
                        baseY: cylHeight/2 + 1,
                        offset: i * 1.5 + (side * 3) // 简单的错开算法
                    });

                    // 初始位置
                    pistonMesh.position.set(0, cylHeight/2 + 1, zPos);
                    sideGroup.add(pistonMesh);
                }
                group.add(sideGroup);
            }

            // 曲轴 (Crankshaft) - 中心的长杆
            const shaft = makeHoloObj(new THREE.CylinderGeometry(0.5, 0.5, 14, 8), 0.5);
            shaft.rotation.x = Math.PI / 2;
            group.add(shaft);

            // 进气歧管/顶部结构 (装饰)
            const topStruct = makeHoloObj(new THREE.BoxGeometry(4, 2, 12), 0.2);
            topStruct.position.y = 5;
            group.add(topStruct);

            return group;
        }

        // --- Model 2: Galaxy (螺旋星系) ---
        function buildGalaxy() {
            const group = new THREE.Group();
            animatables = [];
            const count = 3000;
            const pos = [];
            const colors = [];
            const colorObj = new THREE.Color(config.particleColor);
            const colorCore = new THREE.Color(config.accentColor);

            for(let i=0; i<count; i++){
                // 3条旋臂
                const branch = i % 3;
                const radius = Math.random() * 20 + 1;
                const spinAngle = radius * 0.5; // 越远转得越多
                const branchAngle = (branch / 3) * Math.PI * 2;
                
                const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 2;
                const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 2;
                const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 2;

                const x = Math.cos(branchAngle + spinAngle) * radius + randomX;
                const y = randomY * (20 - radius) * 0.1; // 中心厚，边缘薄
                const z = Math.sin(branchAngle + spinAngle) * radius + randomZ;
                
                pos.push(x, y, z);

                // 颜色：中心亮，边缘暗
                const mixedColor = colorCore.clone().lerp(colorObj, radius / 20);
                colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const mat = new THREE.PointsMaterial({
                size: config.particleSize,
                map: createGlowTexture(),
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            group.add(new THREE.Points(geo, mat));
            
            // 黑洞核心
            const core = makeHoloObj(new THREE.SphereGeometry(1.5, 16, 16), 0.2, matAccent);
            group.add(core);

            return group;
        }

        // --- Model 3: HyperCube (超立方体) ---
        function buildHyperCube() {
            const group = new THREE.Group();
            animatables = [];
            // 嵌套3个立方体
            for(let i=0; i<3; i++) {
                const s = 5 + i * 4;
                const cube = makeHoloObj(new THREE.BoxGeometry(s,s,s), 0.4 + i*0.2);
                animatables.push({ mesh: cube, type: 'rotate', speed: (i+1)*0.2 });
                group.add(cube);
            }
            return group;
        }

        // --- Model 4: Planetary (原行星系统) ---
        function buildPlanetary() {
            const group = new THREE.Group();
            animatables = [];
            
            // 太阳
            group.add(makeHoloObj(new THREE.TorusGeometry(5, 1, 8, 30), 0.6));
            // 行星架
            const frame = new THREE.Group();
            animatables.push({ mesh: frame, type: 'rotate', speed: 0.3 });
            
            for(let i=0; i<4; i++){
                const angle = (i/4)*Math.PI*2;
                const p = makeHoloObj(new THREE.CylinderGeometry(2,2,1,16), 0.4);
                p.position.set(Math.cos(angle)*10, Math.sin(angle)*10, 0);
                p.rotation.x = Math.PI/2;
                // 行星自转
                animatables.push({ mesh: p, type: 'rotate', speed: 1.0 });
                frame.add(p);
            }
            group.add(frame);
            group.add(makeHoloObj(new THREE.TorusGeometry(16, 0.2, 4, 80), 0.2)); // 外环
            return group;
        }

        function switchModel(name) {
            scene.remove(currentGroup);
            if(name === 'V8 Engine') currentGroup = buildV8();
            if(name === 'Galaxy') currentGroup = buildGalaxy();
            if(name === 'HyperCube') currentGroup = buildHyperCube();
            if(name === 'Planetary') currentGroup = buildPlanetary();
            scene.add(currentGroup);
        }

        // 初始模型
        switchModel(config.model);

        // ==========================================
        // 5. GUI 面板
        // ==========================================
        const gui = new GUI({ title: 'HOLO-SYSTEM' });
        gui.domElement.style.top = '20px'; gui.domElement.style.right = '20px';

        gui.add(config, 'model', ['V8 Engine', 'Galaxy', 'HyperCube', 'Planetary']).name('MODEL SELECT').onChange(switchModel);
        
        const fVisual = gui.addFolder('VISUALS');
        fVisual.addColor(config, 'lineColor').onChange(c => matLine.color.set(c));
        fVisual.addColor(config, 'particleColor').onChange(c => {
            matPart.color.set(c);
            if(config.model === 'Galaxy') switchModel('Galaxy'); // 星系需要重绘颜色
        });
        fVisual.addColor(config, 'accentColor').onChange(c => matAccent.color.set(c));
        fVisual.add(config, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength = v);
        
        const fPhys = gui.addFolder('PHYSICS');
        fPhys.add(config, 'inertiaDamping', 0.8, 0.99).name('Friction');
        fPhys.add(config, 'autoRotate').name('Idle Spin');

        // ==========================================
        // 6. 核心循环 (Animation)
        // ==========================================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // --- A. 物理与手势 ---
            // 惯性阻尼
            state.velocity.x *= config.inertiaDamping;
            state.velocity.y *= config.inertiaDamping;
            
            // 应用旋转
            currentGroup.rotation.y += state.velocity.x;
            currentGroup.rotation.x += state.velocity.y;

            // 自动旋转 (仅当没有手势输入且速度很低时)
            if(config.autoRotate && !state.handDetected && Math.abs(state.velocity.x) < 0.001) {
                currentGroup.rotation.y += delta * 0.15;
            }

            // 平滑缩放
            state.currentZoom += (state.targetZoom - state.currentZoom) * 0.1;
            camera.position.z = state.currentZoom;

            // --- B. 模型内部动画 (V8活塞等) ---
            animatables.forEach(item => {
                if(item.type === 'piston') {
                    // V8 活塞运动: sin波形
                    const yOffset = Math.sin(time * 5 + item.offset) * 1.5;
                    item.mesh.position.y = item.baseY + yOffset;
                }
                else if(item.type === 'rotate') {
                    item.mesh.rotation.z += delta * item.speed;
                    item.mesh.rotation.x += delta * item.speed * 0.5;
                }
            });

            // 星系整体自旋
            if(config.model === 'Galaxy') {
                currentGroup.rotation.z += delta * 0.05;
            }

            // --- C. 视觉反馈 ---
            // 距离淡出效果
            const zoomRatio = Math.max(0, Math.min(1, (state.currentZoom - 5) / 40));
            matLine.opacity = 0.2 * zoomRatio; // 离得近线框消失，只剩粒子
            
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==========================================
        // 7. 手势识别 (MediaPipe)
        // ==========================================
        const videoElement = document.getElementById('input-video');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const gestureData = document.getElementById('gesture-data');
        const loader = document.getElementById('loader');

        function onResults(results) {
            if(loader.style.display !== 'none') {
                loader.style.opacity = 0;
                setTimeout(() => loader.style.display = 'none', 500);
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                statusDot.classList.add('active');
                
                const hands = results.multiHandLandmarks;

                if (hands.length === 2) {
                    // 双手缩放
                    state.mode = "ZOOM";
                    statusText.innerText = "ZOOM MODE";
                    const d = Math.sqrt(Math.pow(hands[0][8].x-hands[1][8].x,2) + Math.pow(hands[0][8].y-hands[1][8].y,2));
                    const factor = 1 - Math.min(1, Math.max(0, (d - 0.1) * 2));
                    state.targetZoom = 5 + (factor * 50); // 近5 远55
                    gestureData.innerText = `DIST: ${d.toFixed(2)}`;
                } else {
                    // 单手旋转
                    state.mode = "ROTATE";
                    statusText.innerText = "ROTATE MODE";
                    const currX = hands[0][9].x;
                    const currY = hands[0][9].y;
                    
                    const dx = currX - state.lastHandPos.x;
                    const dy = currY - state.lastHandPos.y;
                    
                    if(Math.abs(dx) > 0.001 || Math.abs(dy) > 0.001) {
                         // 给模型施加力
                        state.velocity.x = dx * config.sensitivity * 8; 
                        state.velocity.y = dy * config.sensitivity * 8;
                    }
                    
                    state.lastHandPos = {x: currX, y: currY};
                    gestureData.innerText = `X:${currX.toFixed(2)} Y:${currY.toFixed(2)}`;
                }
            } else {
                state.handDetected = false;
                statusDot.classList.remove('active');
                statusText.innerText = "SCANNING...";
                gestureData.innerText = "NO HAND";
                state.lastHandPos = {x:0.5, y:0.5}; // 重置中心
            }
        }

        const checkInterval = setInterval(() => {
            if (window.Hands && window.Camera) {
                clearInterval(checkInterval);
                const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7});
                hands.onResults(onResults);
                const cam = new window.Camera(videoElement, {onFrame: async () => await hands.send({image: videoElement}), width: 640, height: 480});
                cam.start();
            }
        }, 500);
    </script>
</body>
</html>
