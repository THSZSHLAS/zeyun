<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°å­—æ™¶ä½“v12</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* æ‘„åƒå¤´é¢„è§ˆï¼šæç®€çº¿æ¡æ¡† */
        #video-input { 
            position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px; 
            transform: scaleX(-1); opacity: 0.3; z-index: 2; 
            border: 2px solid #fff; border-radius: 0;
            pointer-events: none; mix-blend-mode: overlay;
        }
        
        /* UI é£æ ¼ï¼šæç®€é»‘ç™½ */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 14px; z-index: 20; pointer-events: none;
            letter-spacing: 4px; text-transform: uppercase; border: 1px solid #fff;
            padding: 10px 20px; background: rgba(0,0,0,0.8);
        }

        /* éšè— GUI çš„å¤§éƒ¨åˆ†è£…é¥°ï¼Œåªç•™æ ¸å¿ƒ */
        .lil-gui { 
            --background-color: #111; 
            --text-color: #fff; 
            --title-background-color: #222;
            --widget-color: #444;
            --focus-color: #fff;
            --width: 200px;
        }
    </style>
</head>
<body>

    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <div id="loader">System Loading...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // --- æ ¸å¿ƒé…ç½® ---
        const config = {
            count: 4000,          // ç²’å­æ•°é‡å‡å°‘ï¼Œä½†å•ä¸ªç²’å­å˜å¤§ï¼Œä¿è¯æ€§èƒ½å’Œæ•´æ´åº¦
            cubeSize: 0.35,       // ğŸ”¥ ç²’å­éå¸¸å¤§ï¼Œåƒç§¯æœ¨ä¸€æ ·
            shape: 'sphere',      // åˆå§‹å½¢çŠ¶
            colorScale: 1.0,      // é¢œè‰²äº®åº¦
            bloomStrength: 1.2,   // è¾‰å…‰å¼ºåº¦
            handZoomSpeed: 0.05,
            handRotateSpeed: 2.0
        };

        // --- åœºæ™¯æ­å»º ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505); // çº¯é»‘åç°èƒŒæ™¯
        // æ·»åŠ ä¸€ç‚¹ç¯å¢ƒé›¾ï¼Œè®©è¿œå¤„çš„æ–¹å—å˜æš—ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ
        scene.fog = new THREE.Fog(0x050505, 20, 50);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 30; // é»˜è®¤è·ç¦»

        const renderer = new THREE.WebGLRenderer({ antialias: false }); // å…³é—­æŠ—é”¯é½¿ï¼Œè¿½æ±‚é”åˆ©åƒç´ æ„Ÿ
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // --- åæœŸå¤„ç† (Bloom è¾‰å…‰) ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = config.bloomStrength;
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- æ ¸å¿ƒï¼šInstancedMesh (é«˜æ€§èƒ½å®ä½“ç²’å­) ---
        // æˆ‘ä»¬ä½¿ç”¨ BoxGeometry (ç«‹æ–¹ä½“) è€Œä¸æ˜¯ Point (ç‚¹)
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff }); // åŸºç¡€æè´¨ï¼Œé¢œè‰²é€šè¿‡ InstanceColor æ§åˆ¶
        const mesh = new THREE.InstancedMesh(geometry, material, config.count);
        scene.add(mesh);

        // å­˜å‚¨ä½ç½®æ•°æ®çš„æ•°ç»„
        const dummy = new THREE.Object3D();
        const positions = []; // å½“å‰ä½ç½®
        const targets = [];   // ç›®æ ‡ä½ç½®
        const colors = [];    // é¢œè‰²æ•°æ®

        // --- å½¢çŠ¶ç”Ÿæˆç®—æ³• (æ•°å­¦ç§©åºç¾) ---
        
        // 1. æ–æ³¢é‚£å¥‘çƒä½“ (Fibonacci Sphere) - æåº¦å‡åŒ€çš„çƒä½“åˆ†å¸ƒ
        function getSphereLayout() {
            const layout = [];
            const phi = Math.PI * (3 - Math.sqrt(5)); // é»„é‡‘è§’
            for (let i = 0; i < config.count; i++) {
                const y = 1 - (i / (config.count - 1)) * 2; // y ä» 1 åˆ° -1
                const radius = Math.sqrt(1 - y * y);
                const theta = phi * i;
                
                const r = 10; // çƒä½“åŠå¾„
                layout.push(
                    Math.cos(theta) * radius * r,
                    y * r,
                    Math.sin(theta) * radius * r
                );
            }
            return layout;
        }

        // 2. æ™¶æ ¼ç«‹æ–¹ä½“ (Lattice Cube) - æ•´é½çš„çŸ©é˜µ
        function getCubeLayout() {
            const layout = [];
            const side = Math.cbrt(config.count); // è®¡ç®—ç«‹æ–¹ä½“è¾¹é•¿ä¸Šæœ‰å¤šå°‘ä¸ªç²’å­
            const step = 15 / side; // é—´è·
            const offset = (side * step) / 2;
            
            let i = 0;
            for(let x=0; x<side; x++) {
                for(let y=0; y<side; y++) {
                    for(let z=0; z<side; z++) {
                        if (i >= config.count) break;
                        layout.push(
                            x * step - offset,
                            y * step - offset,
                            z * step - offset
                        );
                        i++;
                    }
                }
            }
            // è¡¥é½å‰©ä½™ç²’å­(å¦‚æœæœ‰)
            while(layout.length < config.count * 3) layout.push(0,0,0);
            return layout;
        }

        // 3. ç¯é¢ (Torus) - æœ‰åºçš„åœ†ç¯
        function getTorusLayout() {
            const layout = [];
            for(let i=0; i<config.count; i++) {
                const angle = (i / config.count) * Math.PI * 20; // ç»•å¤§åœˆæ¬¡æ•°
                const tubAngle = (i / config.count) * Math.PI * 2; // ç»•ç®¡å­æ¬¡æ•°
                
                const R = 8; // å¤§åŠå¾„
                const r = 3; // ç®¡åŠå¾„
                
                // èºæ—‹åˆ†å¸ƒ
                layout.push(
                    (R + r * Math.cos(angle)) * Math.cos(tubAngle),
                    (R + r * Math.cos(angle)) * Math.sin(tubAngle),
                    r * Math.sin(angle)
                );
            }
            return layout;
        }

        // åˆå§‹åŒ–
        const layoutSphere = getSphereLayout();
        const layoutCube = getCubeLayout();
        const layoutTorus = getTorusLayout();
        
        // å¡«å……åˆå§‹æ•°æ®
        for(let i=0; i<config.count; i++) {
            positions.push(Math.random()*100, Math.random()*100, Math.random()*100);
            targets.push(0,0,0);
            
            // é¢œè‰²ç”Ÿæˆï¼šåŸºäºç´¢å¼•çš„å½©è™¹æ¸å˜ï¼Œçœ‹èµ·æ¥åƒå…‰è°±
            const color = new THREE.Color();
            color.setHSL(i / config.count, 0.8, 0.6); // HSL å½©è™¹è‰²
            mesh.setColorAt(i, color);
        }
        mesh.instanceColor.needsUpdate = true;

        // åˆ‡æ¢ç›®æ ‡å½¢çŠ¶
        function setShape(shapeName) {
            let data;
            if (shapeName === 'sphere') data = layoutSphere;
            else if (shapeName === 'cube') data = layoutCube;
            else if (shapeName === 'torus') data = layoutTorus;

            for(let i=0; i<config.count; i++) {
                targets[i*3] = data[i*3] || 0;
                targets[i*3+1] = data[i*3+1] || 0;
                targets[i*3+2] = data[i*3+2] || 0;
            }
        }
        setShape('sphere');

        // --- æ‰‹åŠ¿æ§åˆ¶é€»è¾‘ ---
        let targetZoom = 30; // ç›®æ ‡æ‘„åƒæœºZè½´è·ç¦»
        let targetRotY = 0;  // ç›®æ ‡åœºæ™¯æ—‹è½¬Y
        
        const videoElement = document.getElementById('video-input');
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hands = results.multiHandLandmarks;
                
                // 1. è®¡ç®—ç¼©æ”¾ (åŸºäºä¸¤æ‰‹è·ç¦» æˆ– å•æ‰‹å¼ å¼€è·ç¦»)
                let pinchDist = 0;
                let centerX = 0;

                if (hands.length === 2) {
                    // åŒæ‰‹ï¼šè®¡ç®—ä¸¤åªæ‰‹è…•çš„è·ç¦»
                    const h1 = hands[0][0]; const h2 = hands[1][0];
                    pinchDist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                    centerX = (h1.x + h2.x) / 2;
                } else {
                    // å•æ‰‹ï¼šè®¡ç®—æ‹‡æŒ‡å’Œå°æŒ‡è·ç¦»
                    const h1 = hands[0][4]; const h2 = hands[0][20];
                    pinchDist = Math.hypot(h1.x - h2.x, h1.y - h2.y) * 2.0; // æ”¾å¤§ç³»æ•°
                    centerX = hands[0][9].x;
                }

                // æ˜ å°„ç¼©æ”¾: è·ç¦»è¶Šè¿‘ -> æ‘„åƒæœºè¶Šè¿œ(Zoom Out)ï¼Œè·ç¦»è¶Šè¿œ -> æ‘„åƒæœºè¶Šè¿‘(Zoom In)
                // pinchDist 0.1 (åˆæ‹¢) ~ 0.8 (å¼ å¼€)
                // Camera Z: 15 (è¿‘) ~ 60 (è¿œ)
                const zoomFactor = 1.0 - Math.min(Math.max(pinchDist, 0.1), 0.8); // å½’ä¸€åŒ–åè½¬
                targetZoom = 15 + zoomFactor * 45;

                // 2. è®¡ç®—æ—‹è½¬ (åŸºäºæ‰‹åœ¨å±å¹•çš„å·¦å³ä½ç½®)
                // centerX 0 (å·¦) ~ 1 (å³)
                // æ˜ å°„åˆ°æ—‹è½¬é€Ÿåº¦
                targetRotY += (centerX - 0.5) * config.handRotateSpeed * 0.1;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });
        cameraUtils.start();

        // --- GUI ---
        const gui = new GUI({ title: 'System Control' });
        const params = { shape: 'sphere' };
        gui.add(params, 'shape', ['sphere', 'cube', 'torus']).name('Structure').onChange(setShape);
        gui.add(config, 'cubeSize', 0.1, 0.8).name('Voxel Size');
        gui.add(config, 'bloomStrength', 0, 3).name('Glow Level').onChange(v => bloomPass.strength = v);

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. å¹³æ»‘æ‰‹åŠ¿æ§åˆ¶
            // æ‘„åƒæœºç¼©æ”¾å¹³æ»‘
            camera.position.z += (targetZoom - camera.position.z) * 0.1;
            // åœºæ™¯æ—‹è½¬å¹³æ»‘ (æ—‹è½¬çš„æ˜¯æ•´ä¸ªmeshå®¹å™¨)
            mesh.rotation.y += (targetRotY - mesh.rotation.y) * 0.05;
            // è‡ªåŠ¨å¾®æ—‹è½¬
            mesh.rotation.x += 0.001;
            mesh.rotation.z += 0.001;

            // 2. ç²’å­æ’å€¼æ›´æ–°
            const time = Date.now() * 0.001;
            
            for (let i = 0; i < config.count; i++) {
                const ix = i * 3; const iy = i * 3 + 1; const iz = i * 3 + 2;
                
                // Lerp ä½ç½®åˆ°ç›®æ ‡
                positions[ix] += (targets[ix] - positions[ix]) * 0.08;
                positions[iy] += (targets[iy] - positions[iy]) * 0.08;
                positions[iz] += (targets[iz] - positions[iz]) * 0.08;

                // è®¾ç½®æ¯ä¸€ä¸ª Instance çš„å˜æ¢çŸ©é˜µ
                dummy.position.set(positions[ix], positions[iy], positions[iz]);
                
                // ğŸ”¥ æ ¸å¿ƒç¾åŒ–ï¼šè®©æ¯ä¸ªæ–¹å—è‡ªè½¬ï¼Œä¸”éšä½ç½®ä¸åŒè€Œä¸åŒï¼Œå¢åŠ é—ªçƒæ„Ÿ
                dummy.rotation.set(time + ix, time + iy, 0); 
                
                // ğŸ”¥ æ ¸å¿ƒç¾åŒ–ï¼šæ ¹æ®ä¸ä¸­å¿ƒçš„è·ç¦»åŠ¨æ€è°ƒæ•´å¤§å°ï¼ˆå‘¼å¸æ„Ÿï¼‰
                // è¶Šé è¿‘ä¸­å¿ƒçš„ç¨å¾®å°ä¸€ç‚¹ï¼Œå¤–é¢çš„å¤§ä¸€ç‚¹ï¼Œæˆ–è€…éšæ—¶é—´æ³¢åŠ¨
                const scale = config.cubeSize * (0.8 + 0.4 * Math.sin(time * 2 + i * 0.1));
                dummy.scale.set(scale, scale, scale);

                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            mesh.instanceMatrix.needsUpdate = true;

            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
