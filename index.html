<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手势控制 3D 粒子系统</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-input { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; transform: scaleX(-1); border-radius: 8px; opacity: 0.7; z-index: 2; border: 2px solid rgba(255,255,255,0.2); }
        
        /* 全屏按钮 */
        #fs-btn {
            position: absolute; bottom: 20px; right: 20px; z-index: 10;
            background: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 20px; border-radius: 30px; cursor: pointer; backdrop-filter: blur(5px);
            transition: all 0.3s;
        }
        #fs-btn:hover { background: white; color: black; }

        /* 加载提示 */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; z-index: 20; pointer-events: none;
            text-shadow: 0 0 10px rgba(0,255,255,0.8);
        }
    </style>
</head>
<body>

    <video id="video-input" playsinline></video>
    
    <div id="canvas-container"></div>
    
    <button id="fs-btn">⛶ 全屏模式</button>
    
    <div id="loader">正在启动摄像头与模型...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';
        // MediaPipe 通过全局脚本加载，但在 module 中我们需要手动处理一下或使用全局变量
        // 为了方便，这里我们假设 MediaPipe 脚本会在后面动态加载，或者我们直接使用全局对象
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        // --- 配置项 ---
        const config = {
            particleCount: 5000,
            particleSize: 0.15,
            color: '#ff0055',
            shape: 'heart', // heart, sphere, spiral, fireworks
            handInteraction: true,
            sensitivity: 2.0 // 手势敏感度
        };

        // --- Three.js 初始化 ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // 添加一点迷雾增强深度感
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;

        // --- 粒子系统核心 ---
        let geometry, material, points;
        const positions = [];       // 当前位置
        const targetPositions = []; // 目标形状位置
        
        // 初始化几何体数据
        function initParticles() {
            if(points) scene.remove(points);

            const posArray = new Float32Array(config.particleCount * 3);
            
            for(let i=0; i<config.particleCount; i++) {
                // 初始随机分布
                positions[i*3] = (Math.random() - 0.5) * 50;
                positions[i*3+1] = (Math.random() - 0.5) * 50;
                positions[i*3+2] = (Math.random() - 0.5) * 50;

                posArray[i*3] = positions[i*3];
                posArray[i*3+1] = positions[i*3+1];
                posArray[i*3+2] = positions[i*3+2];
            }

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

            material = new THREE.PointsMaterial({
                size: config.particleSize,
                color: config.color,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
            
            // 立即计算一次目标形状
            calculateTargetShape(config.shape);
        }

        // --- 形状计算逻辑 ---
        function calculateTargetShape(shapeType) {
            targetPositions.length = 0; // 清空

            for (let i = 0; i < config.particleCount; i++) {
                let x, y, z;

                if (shapeType === 'heart') {
                    // 3D 爱心公式
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    // 使用参数方程的变体
                    // 这里用一个简单的 2D 拉伸成 3D 的爱心
                    const t = Math.random() * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    z = (Math.random() - 0.5) * 5; // 厚度
                    
                    // 稍微打散一点
                    x *= 0.5; y *= 0.5; 
                } 
                else if (shapeType === 'sphere') {
                    // 球体
                    const r = 8;
                    const phi = Math.acos(-1 + (2 * i) / config.particleCount);
                    const theta = Math.sqrt(config.particleCount * Math.PI) * phi;
                    x = r * Math.cos(theta) * Math.sin(phi);
                    y = r * Math.sin(theta) * Math.sin(phi);
                    z = r * Math.cos(phi);
                } 
                else if (shapeType === 'spiral') {
                    // 螺旋 (替代不雅手势)
                    const t = i / config.particleCount * 20;
                    x = t * Math.cos(t * 5);
                    z = t * Math.sin(t * 5);
                    y = t * 2 - 10;
                }
                else if (shapeType === 'fireworks') {
                    // 烟花 (随机爆炸球体)
                    const r = 15 * Math.random();
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                targetPositions.push(x, y, z);
            }
        }

        // --- MediaPipe 手势追踪 ---
        const videoElement = document.getElementById('video-input');
        let handDistanceScale = 1.0; // 默认缩放
        let isHandDetected = false;

        function onResults(results) {
            document.getElementById('loader').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const hands = results.multiHandLandmarks;
                
                // 逻辑：如果检测到两只手，计算两手中心点的距离
                if (hands.length === 2) {
                    const hand1 = hands[0][9]; // 中指根部
                    const hand2 = hands[1][9];
                    
                    // 计算屏幕归一化距离
                    const dx = hand1.x - hand2.x;
                    const dy = hand1.y - hand2.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // 映射距离到缩放系数 (距离越远，系数越大)
                    // 原始距离大概在 0.1 到 0.8 之间
                    let targetScale = 1.0 + (distance * config.sensitivity); 
                    // 平滑过渡
                    handDistanceScale += (targetScale - handDistanceScale) * 0.1;
                    
                } else if (hands.length === 1) {
                    // 如果只有一只手，检测大拇指和食指张开程度
                    const thumb = hands[0][4];
                    const index = hands[0][8];
                    const d = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
                    
                    let targetScale = 1.0 + (d * 5.0); // 单手张开系数
                    handDistanceScale += (targetScale - handDistanceScale) * 0.1;
                }
            } else {
                isHandDetected = false;
                // 无手势时缓慢恢复默认大小
                handDistanceScale += (1.0 - handDistanceScale) * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();

        // --- UI 设置 ---
        const gui = new GUI({ title: '控制面板' });
        
        gui.add(config, 'shape', ['heart', 'sphere', 'spiral', 'fireworks'])
           .name('粒子形状')
           .onChange(val => calculateTargetShape(val));
           
        gui.addColor(config, 'color')
           .name('粒子颜色')
           .onChange(val => material.color.set(val));

        gui.add(config, 'particleSize', 0.01, 1.0)
           .name('粒子大小')
           .onChange(val => material.size = val);
           
        gui.add(config, 'sensitivity', 1.0, 10.0)
           .name('手势敏感度');

        // --- 动画循环 ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            controls.update();

            // 粒子位置更新 (Morphing 逻辑)
            const positionsAttribute = geometry.attributes.position;
            const currentPositions = positionsAttribute.array;

            // 动态缩放基准
            let scaleFactor = config.handInteraction ? handDistanceScale : 1.0;

            for (let i = 0; i < config.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 获取目标位置并应用缩放
                let tx = targetPositions[ix] * scaleFactor;
                let ty = targetPositions[iy] * scaleFactor;
                let tz = targetPositions[iz] * scaleFactor;

                // 增加一些动态噪声 (呼吸感)
                if (config.shape === 'fireworks') {
                    // 烟花特殊逻辑：持续向外扩散
                    tx += Math.sin(time * 2 + i) * 0.5;
                } else {
                    // 普通呼吸
                    tx += Math.sin(time * 3 + i) * 0.05;
                    ty += Math.cos(time * 2 + i) * 0.05;
                }

                // 线性插值 (Lerp) 实现平滑移动
                // 0.05 是移动速度，越小越慢/平滑
                currentPositions[ix] += (tx - currentPositions[ix]) * 0.08;
                currentPositions[iy] += (ty - currentPositions[iy]) * 0.08;
                currentPositions[iz] += (tz - currentPositions[iz]) * 0.08;
            }

            positionsAttribute.needsUpdate = true;
            
            // 颜色动态变化 (可选)
            if (config.shape === 'fireworks') {
                const hue = (time * 0.1) % 1;
                material.color.setHSL(hue, 1, 0.5);
            }

            renderer.render(scene, camera);
        }

        // --- 初始化与事件 ---
        initParticles();
        animate();

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 全屏按钮
        document.getElementById('fs-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.body.requestFullscreen().catch(err => {
                    alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        });

    </script>
</body>
</html>
