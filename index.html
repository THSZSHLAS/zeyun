<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤ªé˜³ç³»ç²’å­</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        /* èƒŒæ™¯ç°åœ¨æ˜¯çº¯é»‘ï¼Œä¾èµ– 3D æ˜Ÿç©º */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: #000; }
        
        #video-input { position: absolute; bottom: 10px; left: 10px; width: 120px; height: 90px; transform: scaleX(-1); border-radius: 8px; opacity: 0.3; z-index: 2; border: 1px solid rgba(255,255,255,0.1); pointer-events: none; transition: opacity 0.3s; mix-blend-mode: screen; }
        #video-input.active { opacity: 0.6; }
        
        #fs-btn {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            background: rgba(0, 0, 0, 0.3); color: rgba(255,255,255,0.8); border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 15px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(10px);
            transition: all 0.3s; font-size: 12px; letter-spacing: 1px;
        }
        #fs-btn:hover { background: rgba(255, 255, 255, 0.1); color: white; border-color: rgba(255,255,255,0.5); box-shadow: 0 0 15px rgba(100,200,255,0.3); }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #4da6ff; font-size: 18px; z-index: 20; pointer-events: none;
            text-shadow: 0 0 20px rgba(77, 166, 255, 0.8); letter-spacing: 3px; text-align: center; font-weight: 300;
        }
        /* ç¾åŒ– GUI é¢æ¿ */
        .lil-gui { --width: 300px; --name-width: 35%; --background-color: rgba(10,15,30,0.7); --text-color: #a0c0ff; --widget-color: #1a2a4a; --hover-color: #2a4a7a; --focus-color: #4da6ff; backdrop-filter: blur(10px); border-radius: 8px; border: 1px solid rgba(77, 166, 255, 0.2) !important; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .lil-gui .title { color: #ffffff; text-shadow: 0 0 10px rgba(77, 166, 255, 0.8); }
    </style>
</head>
<body>

    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <button id="fs-btn">âœ¨ æ²‰æµ¸ä½“éªŒ</button>
    <div id="loader">æ­£åœ¨æ„å»ºå¤ªé˜³ç³»...<br><span style="font-size:12px; opacity:0.6;">é¦–æ¬¡è¿è¡Œè¯·å…è®¸æƒé™ | åŠ è½½ 8ä¸‡ ç²’å­ä¸è¾‰å…‰ç‰¹æ•ˆ</span></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // --- æ ¸å¿ƒé…ç½® ---
        const config = {
            target: 'earth', // é»˜è®¤åœ°çƒ
            // ğŸ”¥ æå¤§æå‡ç²’å­æ•°ï¼Œä½†å‡å°å°ºå¯¸ï¼Œé…åˆè¾‰å…‰æ‰“é€ ç»†è…»æ„Ÿ
            particleCount: 80000, 
            particleSize: 0.035, 
            handSensitivity: 2.0,
            audioReactivity: false,
            autoRotate: true,
            rotationSpeed: 0.2,
            bloomStrength: 1.2, // è¾‰å…‰å¼ºåº¦
            bloomRadius: 0.4    // è¾‰å…‰åŠå¾„
        };

        // --- è¡Œæ˜Ÿæ•°æ®å®šä¹‰ (é¢œè‰²æ¿ä¸ç”Ÿæˆé€»è¾‘) ---
        const planetData = {
            'mercury': { name: 'æ°´æ˜Ÿ Mercury', radius: 10, colors: [0xa1a1a1, 0x787878, 0xcfcfcf], type: 'rocky' },
            'venus': { name: 'é‡‘æ˜Ÿ Venus', radius: 12, colors: [0xe6b87d, 0xc48d4a, 0xffe0b3], type: 'atmosphere' },
            'earth': { name: 'åœ°çƒ Earth', radius: 13, colors: [0x2244ff, 0x11aabb, 0x228833, 0xffffff], type: 'earth' },
            'mars': { name: 'ç«æ˜Ÿ Mars', radius: 11, colors: [0xdd4422, 0xaa3311, 0xff7744, 0x882200], type: 'rocky' },
            'jupiter': { name: 'æœ¨æ˜Ÿ Jupiter', radius: 22, colors: [0xcfaa86, 0xa67d56, 0xe3cdb4, 0x8c5e35], type: 'banded' },
            'saturn': { name: 'åœŸæ˜Ÿ Saturn', radius: 19, colors: [0xe0d2b4, 0xc4b38a], type: 'ringed' },
            'uranus': { name: 'å¤©ç‹æ˜Ÿ Uranus', radius: 16, colors: [0x88ffff, 0x44ccff, 0xaaddff], type: 'atmosphere' },
            'neptune': { name: 'æµ·ç‹æ˜Ÿ Neptune', radius: 15, colors: [0x3355ff, 0x2244dd, 0x5588ff], type: 'atmosphere' },
            'galaxy': { name: 'ğŸŒŒ é“¶æ²³ç³» Core', radius: 30, colors: [0xffaa55, 0xff4488, 0x4422ff, 0xffffff], type: 'galaxy' }
        };

        let handData = { detected: false, distanceSmooth: 0 };
        let audioContext, analyser, dataArray, audioLevelSmooth = 0;

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // ä½¿ç”¨éå¸¸æ·¡çš„æ·±è“è‰²é›¾æ°”ï¼Œå¢åŠ æ·±ç©ºæ„Ÿ
        scene.fog = new THREE.FogExp2(0x020510, 0.008);

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.z = 45;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" }); // å…³é—­æŠ—é”¯é½¿ï¼Œäº¤ç»™åæœŸå¤„ç†
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // ç”µå½±çº§è‰²è°ƒæ˜ å°„
        renderer.toneMappingExposure = 0.9;
        container.appendChild(renderer.domElement);

        // --- åæœŸå¤„ç† (Bloom/è¾‰å…‰) ---
        const renderScene = new RenderPass(scene, camera);
        // åˆ†è¾¨ç‡, å¼ºåº¦, åŠå¾„, é˜ˆå€¼
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), config.bloomStrength, config.bloomRadius, 0.1);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05; controls.autoRotate = true; controls.autoRotateSpeed = config.rotationSpeed;
        controls.enablePan = false;

        // --- èƒŒæ™¯æ˜Ÿç©º ---
        function createStarfield() {
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<5000; i++) {
                const r = 200 + Math.random() * 300;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                starPos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.5, transparent: true, opacity: 0.8, fog: false });
            const stars = new THREE.Points(starGeo, starMat);
            scene.add(stars);
        }
        createStarfield();

        // --- æ ¸å¿ƒç²’å­ç³»ç»Ÿ ---
        let mainPoints, mainGeometry, mainMaterial;
        const targetPositions = [];
        const baseColors = new Float32Array(config.particleCount * 3); // å­˜å‚¨åŸå§‹é¢œè‰²ç”¨äºæ¢å¤
        
        // é«˜å…‰çº¹ç†ï¼Œä¸­å¿ƒæäº®
        function createFlareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(220,240,255,0.8)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function initMainParticles() {
            if (mainPoints) scene.remove(mainPoints);
            const posArray = new Float32Array(config.particleCount * 3);
            const colorsArray = new Float32Array(config.particleCount * 3);

            for (let i = 0; i < config.particleCount; i++) {
                // åˆå§‹çˆ†ç‚¸çŠ¶æ€
                const r = 100 * Math.sqrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                posArray[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                posArray[i * 3+1] = r * Math.sin(phi) * Math.sin(theta);
                posArray[i * 3+2] = r * Math.cos(phi);
                // åˆå§‹ç™½è‰²
                colorsArray[i*3] = colorsArray[i*3+1] = colorsArray[i*3+2] = 1;
            }

            mainGeometry = new THREE.BufferGeometry();
            mainGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            mainGeometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));

            mainMaterial = new THREE.PointsMaterial({
                size: config.particleSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.9, // é«˜é€æ˜åº¦é…åˆè¾‰å…‰
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: createFlareTexture()
            });

            mainPoints = new THREE.Points(mainGeometry, mainMaterial);
            scene.add(mainPoints);
            calculateTarget(config.target);
        }
        
        // --- ç®€å•çš„å™ªå£°å‡½æ•° (ç”¨äºçº¹ç†ç”Ÿæˆ) ---
        function simpleNoise(x, y, z) {
            return Math.sin(x*10 + Math.cos(y*12 + z*15)) * 0.5 + 0.5;
        }

        // --- æ ¸å¿ƒï¼šè¡Œæ˜Ÿç”Ÿæˆç®—æ³• ---
        function calculateTarget(targetKey) {
            targetPositions.length = 0;
            const data = planetData[targetKey];
            const radius = data.radius;
            const colors = data.colors.map(c => new THREE.Color(c));
            const tempColor = new THREE.Color();
            const colorAttribute = mainGeometry.attributes.color;

            for (let i = 0; i < config.particleCount; i++) {
                let x, y, z, rFinal = radius;
                let particleColor;

                // é€šç”¨çƒä½“åæ ‡
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // --- çº¹ç†ä¸é¢œè‰²é€»è¾‘ ---
                if (data.type === 'rocky') {
                    // å²©çŸ³è¡Œæ˜Ÿï¼šåŸºäºå™ªç‚¹çš„æ–‘é©³è¡¨é¢
                    rFinal = radius * (0.98 + Math.random() * 0.04); // ç¨å¾®å‡¹å‡¸ä¸å¹³
                    const noiseVal = simpleNoise(phi*3, theta*3, i*0.001);
                    particleColor = colors[Math.floor(noiseVal * colors.length * 0.99)];
                } 
                else if (data.type === 'atmosphere') {
                    // å¤§æ°”è¡Œæ˜Ÿï¼šå¹³æ»‘ï¼Œé¢œè‰²æ¸å˜
                    rFinal = radius * (0.99 + Math.random() * 0.02);
                    particleColor = colors[Math.floor(Math.random() * colors.length)];
                    // è¾¹ç¼˜ç¨å¾®äº®ä¸€ç‚¹ï¼Œæ¨¡æ‹Ÿå¤§æ°”å±‚
                    if (Math.sin(phi) < 0.3) particleColor.clone().lerp(new THREE.Color(0xffffff), 0.3);
                }
                else if (data.type === 'earth') {
                    // åœ°çƒï¼šå¤æ‚çš„æµ·æ´‹/é™†åœ°/äº‘å±‚é€»è¾‘
                    rFinal = radius;
                    const lat = Math.abs(Math.cos(phi)); // 0èµ¤é“ 1ä¸¤æ
                    const noiseLand = simpleNoise(phi*4, theta*4, 0); // å¤§é™†å™ªç‚¹
                    const noiseCloud = simpleNoise(phi*6 + 10, theta*6 + 10, i*0.01); // äº‘å±‚å™ªç‚¹

                    if (noiseCloud > 0.65) {
                        particleColor = colors[3]; // äº‘ (ç™½)
                        rFinal += 0.3; // äº‘å±‚æµ®èµ·
                    } else if (noiseLand > 0.55 && lat < 0.9) {
                         particleColor = colors[2]; // é™†åœ° (ç»¿)
                         // ç¨å¾®åŠ ç‚¹å™ªç‚¹æ¨¡æ‹Ÿåœ°å½¢
                         if (simpleNoise(phi*10, theta*10, 5) > 0.5) particleColor.lerp(new THREE.Color(0x886633), 0.5); // å±±åœ°
                    } else {
                        particleColor = colors[0].clone().lerp(colors[1], lat); // æµ·æ´‹ (æ·±è“åˆ°æµ…è“)
                    }
                }
                else if (data.type === 'banded') {
                    // æœ¨æ˜Ÿï¼šåŸºäºçº¬åº¦(y)çš„æ¡çº¹
                    const latNorm = (Math.cos(phi) + 1) / 2; // 0-1
                    // ä½¿ç”¨æ­£å¼¦å‡½æ•°åˆ›å»ºæ¡çº¹å¸¦
                    const band = Math.sin(latNorm * Math.PI * 12 + simpleNoise(theta, 0, 0)*2);
                    const colorIdx = Math.floor((band * 0.5 + 0.5) * (colors.length - 0.01));
                    particleColor = colors[colorIdx];
                    // åŠ å…¥å¤§çº¢æ–‘ç±»ä¼¼çš„æ‰°åŠ¨
                    if (Math.abs(latNorm - 0.3) < 0.1 && Math.abs(theta - 1) < 0.5) {
                         particleColor.lerp(new THREE.Color(0xff3300), 0.5);
                    }
                }
                else if (data.type === 'ringed') {
                    // åœŸæ˜Ÿï¼šæœ¬ä½“ + å…‰ç¯
                    // 30% ç²’å­åšæœ¬ä½“ï¼Œ70% åšå…‰ç¯
                    if (Math.random() > 0.7) {
                        // æœ¬ä½“
                        rFinal = radius * (0.9 + Math.random()*0.2);
                        const band = Math.sin(Math.cos(phi) * Math.PI * 8);
                        particleColor = colors[band > 0 ? 0 : 1];
                    } else {
                        // å…‰ç¯ (æ‰å¹³åœ†ç›˜)
                        rFinal = radius * (1.5 + Math.random() * 1.2); // å…‰ç¯åŠå¾„èŒƒå›´
                        const ringThickness = 0.5;
                        // é‡æ–°è®¡ç®—åæ ‡ä¸ºåœ†ç›˜
                        x = rFinal * Math.cos(theta);
                        z = rFinal * Math.sin(theta);
                        y = (Math.random() - 0.5) * ringThickness; // æè–„
                        
                        // å…‰ç¯çº¹ç†ï¼šåŸºäºåŠå¾„çš„ç¯çŠ¶æ¡çº¹
                        const ringBand = Math.sin(rFinal * 2);
                        particleColor = colors[ringBand > 0 ? 0 : 1].clone().multiplyScalar(0.8); // å…‰ç¯ç¨å¾®æš—ç‚¹
                        
                        // å¼ºåˆ¶è®¾ç½®ä½ç½®å¹¶è·³è¿‡åé¢çš„çƒä½“è®¡ç®—
                        targetPositions.push(x, y, z);
                        baseColors[i*3] = particleColor.r; baseColors[i*3+1] = particleColor.g; baseColors[i*3+2] = particleColor.b;
                        continue; 
                    }
                }
                 else if (data.type === 'galaxy') {
                    // é“¶æ²³ç³»æ ¸å¿ƒ
                    const r = radius * Math.pow(Math.random(), 0.5); // ä¸­å¿ƒå¯†é›†
                    const spiralOffset = r * 0.2; // æ—‹è‡‚æ‰­æ›²
                    x = r * Math.cos(theta + spiralOffset);
                    z = r * Math.sin(theta + spiralOffset);
                    y = (Math.random()-0.5) * r * 0.3 * (1 - r/radius); // ä¸­å¿ƒåšè¾¹ç¼˜è–„
                    
                    // é¢œè‰²åŸºäºåŠå¾„ï¼šä¸­å¿ƒäº®é»„ç™½ï¼Œè¾¹ç¼˜ç´«çº¢è“
                    const rNorm = r / radius;
                    if (rNorm < 0.2) particleColor = colors[3]; // Core white
                    else if (rNorm < 0.5) particleColor = colors[0]; // Yellow/Orange
                    else if (rNorm < 0.8) particleColor = colors[1]; // Red/Pink
                    else particleColor = colors[2]; // Blue outer
                    
                    targetPositions.push(x, y, z);
                    baseColors[i*3] = particleColor.r; baseColors[i*3+1] = particleColor.g; baseColors[i*3+2] = particleColor.b;
                    continue;
                }

                // æ ‡å‡†çƒä½“ä½ç½®è®¡ç®— (å¦‚æœåœ¨ä¸Šé¢æ²¡æœ‰ continue)
                x = rFinal * Math.sin(phi) * Math.cos(theta);
                y = rFinal * Math.sin(phi) * Math.sin(theta);
                z = rFinal * Math.cos(phi);

                targetPositions.push(x, y, z);
                // å­˜å‚¨åŸºå‡†é¢œè‰²
                baseColors[i*3] = particleColor.r;
                baseColors[i*3+1] = particleColor.g;
                baseColors[i*3+2] = particleColor.b;
            }
        }

        // --- éŸ³é¢‘ä¸äº¤äº’ ---
        async function setupAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                audioContext.createMediaStreamSource(stream).connect(analyser);
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            } catch (e) { console.warn("Audio failed", e); config.audioReactivity = false; }
        }

        const videoElement = document.getElementById('video-input');
        function onHandsResults(results) {
            document.getElementById('loader').style.display = 'none';
            videoElement.classList.add('active');
            handData.detected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;
            if (handData.detected) {
                const hands = results.multiHandLandmarks;
                let newDistance = 0;
                if (hands.length === 2) {
                    const h1 = hands[0][0]; const h2 = hands[1][0];
                    newDistance = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                } else if (hands.length === 1) {
                    const h1 = hands[0][4]; const h2 = hands[0][8];
                    newDistance = Math.hypot(h1.x - h2.x, h1.y - h2.y) * 2.0;
                }
                // æ˜ å°„è·ç¦»ï¼Œæ‰‹å¼ å¼€æ—¶æ”¾å¤§
                let targetScale = (newDistance - 0.1) * config.handSensitivity;
                handData.distanceSmooth += (targetScale - handData.distanceSmooth) * 0.1;
            } else {
                 handData.distanceSmooth += (0 - handData.distanceSmooth) * 0.05; // ç¼“æ…¢å¤ä½
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onHandsResults);
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 240, height: 180 });

        // --- GUI ---
        const gui = new GUI({ title: 'ğŸš€ æ˜Ÿé™…èˆªè¡Œç»ˆç«¯' });
        const planetSelect = {};
        for(let key in planetData) planetSelect[planetData[key].name] = key;
        
        gui.add(config, 'target', planetSelect).name('é€‰æ‹©ç›®çš„åœ°').onChange(v => {
            calculateTarget(v);
            // åˆ‡æ¢æ—¶åŠ ä¸€ä¸ªçŸ­æš‚çš„æ—‹è½¬åŠ é€Ÿæ•ˆæœ
            controls.autoRotateSpeed = 5.0;
            setTimeout(() => { controls.autoRotateSpeed = config.rotationSpeed; }, 1000);
        });

        const folderEffects = gui.addFolder('è§†è§‰ä¸äº¤äº’').close();
        folderEffects.add(config, 'audioReactivity').name('ğŸµ éŸ³é¢‘å¾‹åŠ¨').onChange(v => { if (v && !audioContext) setupAudio(); });
        folderEffects.add(config, 'bloomStrength', 0, 3).name('âœ¨ è¾‰å…‰å¼ºåº¦').onChange(v => bloomPass.strength = v);
        folderEffects.add(config, 'rotationSpeed', 0, 1).name('ğŸ”„ è‡ªè½¬é€Ÿåº¦').onChange(v => controls.autoRotateSpeed = v);
        folderEffects.add(mainMaterial, 'size', 0.01, 0.1).name('ğŸ’  ç²’å­å¤§å°');

        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.autoRotate = config.autoRotate;
            controls.update();

            if (config.audioReactivity && analyser) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0; for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
                audioLevelSmooth += (sum / dataArray.length / 256 - audioLevelSmooth) * 0.2;
            } else audioLevelSmooth = 0;

            const positions = mainGeometry.attributes.position.array;
            const colors = mainGeometry.attributes.color.array;

            // åŸºç¡€ç¼©æ”¾ + æ‰‹åŠ¿æ§åˆ¶ + éŸ³é¢‘å¾‹åŠ¨
            let baseScale = 1.0 + handData.distanceSmooth * 0.8;
            let audioScale = 1.0 + audioLevelSmooth * 0.3;
            let finalScale = baseScale * audioScale;
            
            // éŸ³é¢‘å¯¼è‡´çš„é¢œè‰²äº®åº¦å¢å¼º
            let audioColorBoost = audioLevelSmooth * 0.5;

            for (let i = 0; i < config.particleCount; i++) {
                const ix = i * 3; const iy = i * 3 + 1; const iz = i * 3 + 2;
                
                // ç›®æ ‡ä½ç½®
                let tx = targetPositions[ix] * finalScale;
                let ty = targetPositions[iy] * finalScale;
                let tz = targetPositions[iz] * finalScale;

                // æ·»åŠ éå¸¸ç¼“æ…¢ã€å¾®å°çš„å™ªç‚¹ç§»åŠ¨ï¼Œæ¨¡æ‹Ÿå¤§æ°”æµåŠ¨/æ˜Ÿå…‰é—ªçƒï¼Œè€Œä¸æ˜¯å‰§çƒˆå˜å½¢
                const noiseScale = 0.02;
                const noiseSpeed = time * 0.1;
                tx += Math.sin(positions[iy]*noiseScale + noiseSpeed) * 0.15;
                ty += Math.cos(positions[iz]*noiseScale + noiseSpeed*1.1) * 0.15;
                tz += Math.sin(positions[ix]*noiseScale + noiseSpeed*1.2) * 0.15;
                
                // å¹³æ»‘æ’å€¼ç§»åŠ¨
                positions[ix] += (tx - positions[ix]) * 0.05;
                positions[iy] += (ty - positions[iy]) * 0.05;
                positions[iz] += (tz - positions[iz]) * 0.05;

                // é¢œè‰²æ›´æ–° (åŸºäºåŸå§‹é¢œè‰² + éŸ³é¢‘å¢å¼º)
                colors[ix] = Math.min(1, baseColors[ix] + audioColorBoost);
                colors[iy] = Math.min(1, baseColors[iy] + audioColorBoost);
                colors[iz] = Math.min(1, baseColors[iz] + audioColorBoost);
            }
            mainGeometry.attributes.position.needsUpdate = true;
            mainGeometry.attributes.color.needsUpdate = true;

            // ä½¿ç”¨åæœŸå¤„ç†ç»„åˆå™¨è¿›è¡Œæ¸²æŸ“
            composer.render();
        }

        initMainParticles();
        cameraUtils.start().catch(e=>console.error(e));
        animate();

        window.addEventListener('resize', () => { 
            camera.aspect = window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight); // æ›´æ–° composer å°ºå¯¸
        });
        document.getElementById('fs-btn').addEventListener('click', () => { if (!document.fullscreenElement) document.body.requestFullscreen(); else document.exitFullscreen(); });
    </script>
</body>
</html>
