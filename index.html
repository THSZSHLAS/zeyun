<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’å­ç³»ç»Ÿv1.7</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        /* èƒŒæ™¯è°ƒæ·±ä¸€ç‚¹ï¼Œè®©å¤§ç²’å­æ›´çªæ˜¾ */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: radial-gradient(circle at center, #0a0a0a 0%, #000000 100%); }
        
        #video-input { position: absolute; bottom: 10px; left: 10px; width: 120px; height: 90px; transform: scaleX(-1); border-radius: 8px; opacity: 0.4; z-index: 2; border: 1px solid rgba(255,255,255,0.2); pointer-events: none; transition: opacity 0.3s; }
        #video-input.active { opacity: 0.8; }
        
        #fs-btn {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            background: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 15px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(5px);
            transition: all 0.3s; font-size: 14px;
        }
        #fs-btn:hover { background: white; color: black; }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff0055; font-size: 20px; z-index: 20; pointer-events: none;
            text-shadow: 0 0 15px rgba(255,0,85,0.5); letter-spacing: 2px; text-align: center;
        }
        .lil-gui { --width: 280px; --name-width: 40%; }
    </style>
</head>
<body>

    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <button id="fs-btn">â›¶ å…¨å±æ²‰æµ¸</button>
    <div id="loader">æ­£åœ¨æ„å»º 3D çˆ±å¿ƒ...<br><span style="font-size:14px; opacity:0.7;">é¦–æ¬¡è¿è¡Œè¯·å…è®¸æ‘„åƒå¤´/éº¦å…‹é£æƒé™</span></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        // å†…éƒ¨å™ªå£°ç±»
        class ImprovedNoise {
            constructor() {
                const p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
                for(let i=0; i<256; i++) p[256+i] = p[i];
                this.p = p;
            }
            noise(x, y, z) {
                const p = this.p, fade = t => t * t * t * (t * (t * 6 - 15) + 10), lerp = (t, a, b) => a + t * (b - a);
                const grad = (hash, x, y, z) => { const h = hash & 15; const u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z; return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v); };
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
                x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                const u = fade(x), v = fade(y), w = fade(z);
                const A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;
                return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z)), lerp(u, grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z))), lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1)), lerp(u, grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1))));
            }
        }

        const config = {
            shape: 'perfectHeart', // é»˜è®¤é€‰ä¸­å®Œç¾çˆ±å¿ƒ
            // ğŸ”¥ è°ƒæ•´ç²’å­æ•°é‡å’Œå¤§å°ä»¥è¾¾åˆ°â€œæ¸…æ™°å¯è§â€çš„æ•ˆæœ
            particleCount: 40000, 
            particleSize: 0.20,   // ğŸ”¥ å¢å¤§ï¼ä¹‹å‰æ˜¯ 0.06ï¼Œç°åœ¨ 0.20
            handSensitivity: 2.5,
            audioReactivity: false,
            autoRotate: true
        };

        // é¢œè‰²ï¼šä¿ç•™å¹¿å—å¥½è¯„çš„éœ“è™¹é…è‰²
        const colorPalette = [0xff0055, 0x00ddff, 0xffdd00, 0xffffff];

        let handData = { detected: false, distanceRaw: 0, distanceSmooth: 0 };
        let audioContext, analyser, dataArray;
        let audioLevelRaw = 0, audioLevelSmooth = 0;

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.01); // é›¾æ°”å†æ·¡ä¸€ç‚¹ï¼Œè®©ç²’å­æ›´é€äº®

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.z = 35; // ç¨å¾®å†æ‹‰è¿œä¸€ç‚¹

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotateSpeed = 0.5;

        // --- ç²’å­ç³»ç»Ÿåˆå§‹åŒ– ---
        let mainPoints, mainGeometry, mainMaterial;
        const targetPositions = [];
        const noise = new ImprovedNoise();

        // çº¹ç†ï¼šæ›´å®å¿ƒã€æ›´äº®
        function createBrightTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64; // åˆ†è¾¨ç‡æé«˜
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');     // æ ¸å¿ƒçº¯ç™½
            gradient.addColorStop(0.3, 'rgba(255,255,255,0.6)'); // äº®å…‰æ™•
            gradient.addColorStop(1, 'rgba(0,0,0,0)');           // è¾¹ç¼˜
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function initMainParticles() {
            if (mainPoints) scene.remove(mainPoints);
            const posArray = new Float32Array(config.particleCount * 3);
            const colorsArray = new Float32Array(config.particleCount * 3);
            const tempColor = new THREE.Color();

            for (let i = 0; i < config.particleCount; i++) {
                const x = (Math.random()-0.5)*60;
                const y = (Math.random()-0.5)*60;
                const z = (Math.random()-0.5)*60;
                posArray[i * 3] = x; posArray[i * 3 + 1] = y; posArray[i * 3 + 2] = z;

                const randomColorHex = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                tempColor.setHex(randomColorHex);
                // é¢œè‰²æ›´çº¯ï¼Œå‡å°‘éšæœºæ‚è‰²
                colorsArray[i * 3] = tempColor.r; colorsArray[i * 3 + 1] = tempColor.g; colorsArray[i * 3 + 2] = tempColor.b;
            }

            mainGeometry = new THREE.BufferGeometry();
            mainGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            mainGeometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));

            mainMaterial = new THREE.PointsMaterial({
                size: config.particleSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.8, // ä¿æŒé«˜é€æ˜åº¦
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: createBrightTexture()
            });

            mainPoints = new THREE.Points(mainGeometry, mainMaterial);
            scene.add(mainPoints);
            calculateTargetShape(config.shape);
        }
        
        // --- æ ¸å¿ƒæ›´æ–°ï¼šæ›´å®Œç¾çš„å½¢çŠ¶ç®—æ³• ---
        function calculateTargetShape(shapeType) {
            targetPositions.length = 0;
            let x, y, z;
            
            for (let i = 0; i < config.particleCount; i++) {
                
                if (shapeType === 'perfectHeart') {
                    // ğŸ”¥ å®Œç¾çˆ±å¿ƒç®—æ³• v3.0
                    // é€»è¾‘ï¼š70% çš„ç²’å­ç”¨äºå‹¾å‹’è½®å»“ï¼ˆè®©å½¢çŠ¶æ¸…æ™°ï¼‰ï¼Œ30% çš„ç²’å­å¡«å……å†…éƒ¨ï¼ˆè®©å½¢çŠ¶æœ‰ä½“ç§¯ï¼‰
                    
                    const t = Math.random() * Math.PI * 2;
                    let scale = 1;
                    
                    // å†³å®šè¿™ä¸ªç²’å­æ˜¯åœ¨è¡¨é¢è¿˜æ˜¯å†…éƒ¨
                    if (Math.random() < 0.7) {
                        // è¡¨é¢ç²’å­ï¼šç¨å¾®ä¸€ç‚¹ç‚¹éšæœºåç§»ï¼Œå½¢æˆâ€œæ¯›èŒ¸èŒ¸â€çš„è¾¹ç¼˜
                        scale = 0.95 + Math.random() * 0.1; 
                    } else {
                        // å†…éƒ¨ç²’å­ï¼šå‡åŒ€åˆ†å¸ƒåœ¨å†…éƒ¨
                        scale = Math.pow(Math.random(), 0.5); // å¼€æ–¹åˆ†å¸ƒé˜²æ­¢èšé›†åœ¨ä¸­å¿ƒ
                    }

                    // 2D åŸºç¡€è½®å»“
                    const x2d = 16 * Math.pow(Math.sin(t), 3);
                    const y2d = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);

                    x = x2d * scale;
                    y = y2d * scale;

                    // Zè½´ (åšåº¦) è®¡ç®—
                    // è¿™é‡Œçš„å…³é”®æ˜¯ï¼šè¶Šé è¿‘è¾¹ç¼˜ï¼ˆscale è¶Šå¤§ï¼‰ï¼ŒZ è¶Šè–„ï¼›è¶Šé è¿‘ä¸­å¿ƒï¼ŒZ è¶Šåšã€‚
                    // è¿™ä¼šè®©çˆ±å¿ƒçœ‹èµ·æ¥åƒä¸€ä¸ªé¼“èµ·æ¥çš„æ°”çƒ/æŠ±æ•ã€‚
                    const maxThickness = 6;
                    // åšåº¦åŸºäº scale åå‘ï¼ŒåŒæ—¶å— x åæ ‡å½±å“ï¼ˆçˆ±å¿ƒå·¦å³ä¸¤ä¾§è–„ï¼Œä¸­é—´åšï¼‰
                    // è¿™æ˜¯ä¸€ä¸ªç»éªŒå…¬å¼ï¼Œèƒ½äº§ç”Ÿå¾ˆå¥½çš„ä½“ç§¯æ„Ÿ
                    const thicknessFactor = Math.sqrt(1 - (scale-0.3)/(1-0.3)); // ç®€åŒ–çš„æ¤­çƒä½“æ¨¡æ‹Ÿ
                    
                    z = (Math.random() - 0.5) * maxThickness * (Number.isNaN(thicknessFactor) ? 1 : thicknessFactor) * 2;
                    
                    // æ•´ä½“ç¼©æ”¾é€‚åº”å±å¹•
                    x *= 0.8; y *= 0.8; z *= 0.8;
                    y += 5; // ä¸Šç§»å±…ä¸­

                } else if (shapeType === 'sphere') {
                    const r = 16 * Math.cbrt(Math.random()); 
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta); y = r * Math.sin(phi) * Math.sin(theta); z = r * Math.cos(phi);
                } else if (shapeType === 'torusKnot') {
                    const t = (i / config.particleCount) * Math.PI * 2 * 3;
                    const r = 9 + 3 * Math.cos(3 * t); 
                    x = r * Math.cos(2 * t); y = r * Math.sin(2 * t); z = 7 * Math.sin(3 * t);
                    x += (Math.random()-0.5)*3.0; y += (Math.random()-0.5)*3.0; z += (Math.random()-0.5)*3.0;
                } else if (shapeType === 'dna') {
                    const t = (i / config.particleCount) * Math.PI * 18; 
                    const yPos = (i / config.particleCount - 0.5) * 45; 
                    const offset = i % 2 === 0 ? 0 : Math.PI; 
                    const radius = 7;
                    x = radius * Math.cos(t + offset); z = radius * Math.sin(t + offset); y = yPos;
                    // DNA ç²’å­ä¸éœ€è¦é‚£ä¹ˆæ•£ï¼Œè®©å®ƒæ¸…æ™°ç‚¹
                    if (Math.random() > 0.8) { x *= Math.random()*1.5; z *= Math.random()*1.5; }
                }
                targetPositions.push(x, y, z);
            }
        }

        async function setupAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                audioContext.createMediaStreamSource(stream).connect(analyser);
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            } catch (e) {
                console.warn("Audio init failed", e);
                config.audioReactivity = false;
            }
        }

        const videoElement = document.getElementById('video-input');
        function onHandsResults(results) {
            document.getElementById('loader').style.display = 'none';
            videoElement.classList.add('active');
            handData.detected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;
            
            if (handData.detected) {
                const hands = results.multiHandLandmarks;
                
                let newDistance = 0;
                if (hands.length === 2) {
                    const h1 = hands[0][0]; const h2 = hands[1][0];
                    newDistance = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                } else if (hands.length === 1) {
                    const h1 = hands[0][4]; const h2 = hands[0][8];
                    newDistance = Math.hypot(h1.x - h2.x, h1.y - h2.y) * 2.0;
                }
                handData.distanceRaw = Math.max(0, (newDistance - 0.1) * config.handSensitivity);

            } else {
                handData.distanceRaw = 0;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onHandsResults);
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });

        const gui = new GUI({ title: 'æ§åˆ¶ç»ˆç«¯ v7.0' });
        // åªä¿ç•™å˜å½¢è®¾ç½®ï¼Œç”»ç¬”å·²åˆ é™¤
        const f1 = gui.addFolder('å½¢çŠ¶æ§åˆ¶').open();
        f1.add(config, 'shape', { 'ğŸ’– å®Œç¾çˆ±å¿ƒ': 'perfectHeart', 'ğŸ§¬ DNA é“¾': 'dna', 'ğŸ© ç¯é¢ç»“': 'torusKnot', 'ğŸ”® çƒä½“': 'sphere' }).onChange(v => calculateTargetShape(v));
        f1.add(config, 'audioReactivity').name('ğŸµ éŸ³é¢‘è·³åŠ¨').onChange(v => { if (v && !audioContext) setupAudio(); });
        f1.add(config, 'particleSize', 0.1, 0.5).name('âœ¨ ç²’å­å¤§å°').onChange(v => mainMaterial.size = v); // åŠ¨æ€è°ƒæ•´å¤§å°

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.autoRotate = config.autoRotate;
            controls.update();

            handData.distanceSmooth += (handData.distanceRaw - handData.distanceSmooth) * 0.1;
            
            if (config.audioReactivity && analyser) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0; for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
                audioLevelRaw = sum / dataArray.length / 256;
                audioLevelSmooth += (audioLevelRaw - audioLevelSmooth) * 0.2;
            } else audioLevelSmooth = 0;

            const positions = mainGeometry.attributes.position.array;
            let baseScale = 1.0 + handData.distanceSmooth * 1.2;
            let audioScaleBump = 1.0 + audioLevelSmooth * 0.8; 

            for (let i = 0; i < config.particleCount; i++) {
                const ix = i * 3; const iy = i * 3 + 1; const iz = i * 3 + 2;
                let tx = targetPositions[ix] * baseScale * audioScaleBump;
                let ty = targetPositions[iy] * baseScale * audioScaleBump;
                let tz = targetPositions[iz] * baseScale * audioScaleBump;

                const noiseIntensity = 0.3 + audioLevelSmooth * 1.5; 
                tx += noise.noise(positions[ix]*0.06, positions[iy]*0.06, positions[iz]*0.06 + time*0.4) * noiseIntensity;
                ty += noise.noise(positions[ix]*0.06 + 100, positions[iy]*0.06, positions[iz]*0.06 + time*0.4) * noiseIntensity;
                tz += noise.noise(positions[ix]*0.06 + 200, positions[iy]*0.06, positions[iz]*0.06 + time*0.4) * noiseIntensity;
                
                positions[ix] += (tx - positions[ix]) * 0.06;
                positions[iy] += (ty - positions[iy]) * 0.06;
                positions[iz] += (tz - positions[iz]) * 0.06;
            }
            mainGeometry.attributes.position.needsUpdate = true;
            mainMaterial.size = config.particleSize * (1 + audioLevelSmooth * 0.5); // éŸ³é¢‘å¯¹å¤§å°çš„å½±å“ç¨å¾®è°ƒå°ç‚¹ï¼Œå› ä¸ºç²’å­æœ¬æ¥å°±å¤§

            renderer.render(scene, camera);
        }

        initMainParticles();
        cameraUtils.start().catch(e=>console.error(e));
        animate();

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        document.getElementById('fs-btn').addEventListener('click', () => { if (!document.fullscreenElement) document.body.requestFullscreen(); else document.exitFullscreen(); });
    </script>
</body>
</html>
