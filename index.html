<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HOLO-SYSTEM v14 [FIXED]</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Courier New', monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* æ‘„åƒå¤´é¢„è§ˆ */
        #video-input { 
            position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px; 
            transform: scaleX(-1); opacity: 0.3; z-index: 2; 
            border: 2px solid #4facfe; border-radius: 4px;
            pointer-events: none; mix-blend-mode: screen;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.4);
        }
        
        /* HUD ç•Œé¢ */
        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none;
        }
        .hud-line {
            color: #4facfe; font-size: 14px; letter-spacing: 2px; margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(79, 172, 254, 0.8); background: rgba(0,0,0,0.6);
            padding: 4px 10px; border-left: 3px solid #4facfe; display: inline-block;
        }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 14px; z-index: 20; pointer-events: none;
            letter-spacing: 4px; text-transform: uppercase; border: 1px solid #4facfe;
            padding: 20px 40px; background: rgba(0,5,10,0.9);
            box-shadow: 0 0 30px rgba(79, 172, 254, 0.4);
        }

        /* GUI ä¿®å¤ */
        .lil-gui { 
            --background-color: rgba(2, 4, 8, 0.9); 
            --text-color: #aaddff; 
            --title-background-color: #051020;
            --widget-color: #1a3050;
            --focus-color: #4facfe;
            border: 1px solid rgba(79, 172, 254, 0.3);
        }
        .lil-gui .title { color: #4facfe; font-weight: bold; }
    </style>
</head>
<body>

    <div id="hud">
        <div class="hud-line">SYSTEM: ONLINE</div>
        <div class="hud-line">MODE: HOLOGRAPHIC VOXEL</div>
    </div>
    
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <div id="loader">INITIALIZING CORE...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // --- 1. æ ¸å¿ƒé…ç½® (Config) ---
        const config = {
            particleCount: 7000,   // ç²’å­æ•°
            voxelSize: 0.45,       // æ™¶ä½“å¤§å° (æ§åˆ¶æ­¤å‚æ•°ï¼Œè€Œé material.size)
            target: 'earth',       // é»˜è®¤ç›®æ ‡
            bloomStrength: 1.8,    // è¾‰å…‰
            bloomRadius: 0.5,
            handZoomSpeed: 0.08,
            handRotateSpeed: 2.5,
            autoRotate: true
        };

        // --- 2. é¢œè‰²å®šä¹‰ (ç§‘æŠ€è“åŸºè°ƒ) ---
        const C = {
            blue: new THREE.Color(0x4facfe),     // ä¸»è‰² (Electric Blue)
            cyan: new THREE.Color(0x00f2fe),     // é’
            white: new THREE.Color(0xffffff),    // ç™½
            gold: new THREE.Color(0xffd700),     // é‡‘ (å¤ªé˜³/åœŸæ˜Ÿ)
            marsRed: new THREE.Color(0xff4500),  // ç«æ˜Ÿçº¢
            jupiter: new THREE.Color(0xe0a060),  // æœ¨æ˜Ÿè¤
            nepBlue: new THREE.Color(0x1010aa),  // æµ·ç‹æ˜Ÿæ·±è“
            grey: new THREE.Color(0x888888)      // æ°´æ˜Ÿç°
        };

        // --- 3. å™ªå£°ç±» (å†…ç½®ï¼Œé˜²CORSæŠ¥é”™) ---
        class ImprovedNoise{constructor(){const p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];for(let i=0;i<256;i++)p[256+i]=p[i];this.p=p}noise(x,y,z){const p=this.p,fade=t=>t*t*t*(t*(t*6-15)+10),lerp=(t,a,b)=>a+t*(b-a),grad=(hash,x,y,z)=>{const h=hash&15,u=h<8?x:y,v=h<4?y:h===12||h===14?x:z;return((h&1)===0?u:-u)+((h&2)===0?v:-v)};const X=Math.floor(x)&255,Y=Math.floor(y)&255,Z=Math.floor(z)&255;x-=Math.floor(x);y-=Math.floor(y);z-=Math.floor(z);const u=fade(x),v=fade(y),w=fade(z);const A=p[X]+Y,AA=p[A]+Z,AB=p[A+1]+Z,B=p[X+1]+Y,BA=p[B]+Z,BB=p[B+1]+Z;return lerp(w,lerp(v,lerp(u,grad(p[AA],x,y,z),grad(p[BA],x-1,y,z)),lerp(u,grad(p[AB],x,y-1,z),grad(p[BB],x-1,y-1,z))),lerp(v,lerp(u,grad(p[AA+1],x,y,z-1),grad(p[BA+1],x-1,y,z-1)),lerp(u,grad(p[AB+1],x,y-1,z-1),grad(p[BB+1],x-1,y-1,z-1))))}}
        const noise = new ImprovedNoise();

        // --- 4. åœºæ™¯åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020202); 
        scene.fog = new THREE.Fog(0x020202, 20, 60);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.z = 35; 

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // Bloom åæœŸå¤„ç†
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = config.bloomStrength;
        bloomPass.radius = config.bloomRadius;
        composer.addPass(bloomPass);

        // --- 5. ç²’å­ç³»ç»Ÿ (InstancedMesh) ---
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial(); // é¢œè‰²ç”±Instanceæ§åˆ¶
        const mesh = new THREE.InstancedMesh(geometry, material, config.count);
        scene.add(mesh);

        // æ•°æ®æ•°ç»„
        const dummy = new THREE.Object3D();
        const positions = [];       
        const targetPositions = []; 
        const currentColors = [];   
        const targetColors = [];    

        // åˆå§‹åŒ–
        for(let i=0; i<config.count; i++) {
            positions.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
            targetPositions.push(0,0,0);
            currentColors.push(0,0,1);
            targetColors.push(0,0,1);
        }

        // --- 6. å½¢çŠ¶ç”Ÿæˆç®—æ³• (ä¿®å¤ç‰ˆ) ---
        function simpleNoise(x, y, z) {
            return Math.sin(x*10 + Math.cos(y*12 + z*15)) * 0.5 + 0.5;
        }

        function calculateLayout(type) {
            const rBase = 12; // åŸºç¡€åŠå¾„

            for (let i = 0; i < config.count; i++) {
                let x, y, z;
                let c = C.blue;
                
                // é€šç”¨çƒä½“å‚æ•°
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // --- å¤ªé˜³ç³»é€»è¾‘ ---
                if (type === 'sun') { // â˜€ï¸
                    const r = rBase * (0.8 + Math.random() * 0.4);
                    const spike = Math.random() > 0.9 ? 1.5 : 1.0;
                    x = r * spike * Math.sin(phi) * Math.cos(theta);
                    y = r * spike * Math.sin(phi) * Math.sin(theta);
                    z = r * spike * Math.cos(phi);
                    const mix = Math.random();
                    c = mix > 0.6 ? C.white : (mix > 0.3 ? C.gold : C.marsRed);

                } else if (type === 'mercury') { // ğŸŒ‘
                    const r = rBase * 0.5;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    // é™¨çŸ³å‘å™ªç‚¹
                    if(Math.random()>0.8) { x*=0.95; y*=0.95; z*=0.95; }
                    c = C.grey.clone().lerp(C.blue, 0.2);

                } else if (type === 'venus') { // ğŸŒ•
                    const r = rBase * 0.9;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    c = C.gold.clone().lerp(C.white, Math.random()*0.6);

                } else if (type === 'earth') { // ğŸŒ
                    let r = rBase;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    const nVal = simpleNoise(x*0.1, y*0.1, z*0.1);
                    if (nVal > 0.65) { c = new THREE.Color(0x22ee22); x*=1.02; y*=1.02; z*=1.02; } // ç»¿
                    else if (Math.random()>0.9) { c = C.white; x*=1.08; y*=1.08; z*=1.08; } // äº‘
                    else c = C.blue.clone().lerp(C.nepBlue, Math.random()*0.5); // è“

                } else if (type === 'mars') { // ğŸ”´
                    const r = rBase * 0.7;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    c = C.marsRed.clone().lerp(C.gold, Math.random()*0.3);

                } else if (type === 'jupiter') { // ğŸ˜
                    const r = rBase * 1.5;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    // æ¡çº¹
                    const band = Math.sin(y*1.5 + simpleNoise(x,0,z));
                    if(band > 0.5) c = C.jupiter;
                    else if(band > 0) c = C.gold.clone().multiplyScalar(0.7);
                    else c = C.blue.clone().lerp(C.grey, 0.5);

                } else if (type === 'saturn') { // ğŸª
                    if(i < config.count * 0.5) {
                        const r = rBase * 1.2;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                        c = C.gold.clone().multiplyScalar(0.8);
                    } else {
                        const r = rBase * (1.8 + Math.random());
                        const ang = Math.random()*Math.PI*2;
                        x = r * Math.cos(ang);
                        z = r * Math.sin(ang);
                        y = (Math.random()-0.5)*0.5;
                        c = C.blue.clone().lerp(C.white, Math.random());
                    }

                } else if (type === 'uranus') { // âš™ï¸
                    const r = rBase * 1.1;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    // ç«–ç›´ç¯
                    if(i > config.count*0.8) {
                        const ang = Math.random()*Math.PI*2;
                        const rRing = rBase * (1.6 + Math.random()*0.5);
                        x = rRing * Math.cos(ang);
                        y = rRing * Math.sin(ang);
                        z = (Math.random()-0.5)*0.5;
                        c = C.white;
                    } else {
                        c = C.cyan;
                    }

                } else if (type === 'neptune') { // ğŸ”µ
                    const r = rBase * 1.05;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    c = C.nepBlue.clone().lerp(C.blue, Math.random()*0.3);

                } else if (type === 'pluto') { // âšªï¸
                    const r = rBase * 0.4;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    c = C.white.clone().multiplyScalar(0.8);

                } else if (type === 'galaxy') { // ğŸŒŒ
                    const arm = i % 4;
                    const r = Math.random() * rBase * 2.5;
                    const angle = r * 0.4 + (arm * Math.PI * 2 / 4);
                    x = r * Math.cos(angle) + (Math.random()-0.5)*3;
                    z = r * Math.sin(angle) + (Math.random()-0.5)*3;
                    y = (Math.random()-0.5) * (15 - r*0.5);
                    c = (r/rBase < 0.5) ? C.white : (r/rBase < 1.5 ? C.purple : C.blue);
                }

                targetPositions[i*3] = x; targetPositions[i*3+1] = y; targetPositions[i*3+2] = z;
                targetColors[i*3] = c.r; targetColors[i*3+1] = c.g; targetColors[i*3+2] = c.b;
            }
        }

        calculateLayout(config.target);

        // --- 7. æ‰‹åŠ¿æ§åˆ¶ ---
        let targetZoom = 35;
        let targetRotY = 0;
        const videoElement = document.getElementById('video-input');
        
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hands = results.multiHandLandmarks;
                let pinchDist = 0;
                let centerX = 0.5;

                if (hands.length === 2) {
                    const h1 = hands[0][0]; const h2 = hands[1][0];
                    pinchDist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                    centerX = (h1.x + h2.x) / 2;
                } else {
                    const thumb = hands[0][4]; const pinky = hands[0][20];
                    pinchDist = Math.hypot(thumb.x - pinky.x, thumb.y - pinky.y) * 2;
                    centerX = hands[0][9].x;
                }
                const zoomFactor = 1.0 - Math.min(Math.max(pinchDist, 0.1), 0.8);
                targetZoom = 15 + zoomFactor * 50;
                targetRotY += (centerX - 0.5) * config.handRotateSpeed * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });
        cameraUtils.start();

        // --- 8. GUI (ç¡®ä¿é¡ºåºæ­£ç¡®ï¼Œä¿®å¤æŠ¥é”™) ---
        const gui = new GUI({ title: 'CONTROL SYSTEM' });
        const targets = {
            'â˜€ï¸ SUN': 'sun', 'ğŸŒ‘ MERCURY': 'mercury', 'ğŸŒ• VENUS': 'venus',
            'ğŸŒ EARTH': 'earth', 'ğŸ”´ MARS': 'mars', 'ğŸ˜ JUPITER': 'jupiter',
            'ğŸª SATURN': 'saturn', 'âš™ï¸ URANUS': 'uranus', 'ğŸ”µ NEPTUNE': 'neptune',
            'âšªï¸ PLUTO': 'pluto', 'ğŸŒŒ GALAXY': 'galaxy'
        };
        gui.add(config, 'target', targets).name('TARGET').onChange(v => calculateLayout(v));
        // ä¿®å¤ï¼šè¿™é‡Œç»‘å®š config.voxelSize è€Œä¸æ˜¯ material.size
        gui.add(config, 'voxelSize', 0.1, 1.0).name('CRYSTAL SIZE'); 
        gui.add(config, 'bloomStrength', 0, 3).name('GLOW INTENSITY').onChange(v => bloomPass.strength = v);
        gui.add(config, 'autoRotate').name('AUTO ROTATE');

        // --- 9. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // æ‘„åƒæœº
            camera.position.z += (targetZoom - camera.position.z) * 0.05;
            mesh.rotation.y += (targetRotY - mesh.rotation.y) * 0.05;
            if(config.autoRotate) mesh.rotation.y += 0.002;
            mesh.rotation.x = Math.sin(Date.now()*0.0005)*0.05;

            // ç²’å­æ›´æ–°
            const time = Date.now() * 0.001;
            const tempColor = new THREE.Color();

            for (let i = 0; i < config.count; i++) {
                const ix = i*3; const iy = i*3+1; const iz = i*3+2;
                
                positions[ix] += (targetPositions[ix] - positions[ix]) * 0.08;
                positions[iy] += (targetPositions[iy] - positions[iy]) * 0.08;
                positions[iz] += (targetPositions[iz] - positions[iz]) * 0.08;

                currentColors[ix] += (targetColors[ix] - currentColors[ix]) * 0.05;
                currentColors[iy] += (targetColors[iy] - currentColors[iy]) * 0.05;
                currentColors[iz] += (targetColors[iz] - currentColors[iz]) * 0.05;

                dummy.position.set(positions[ix], positions[iy], positions[iz]);
                
                // å‘¼å¸åŠ¨ç”»
                const scale = config.voxelSize * (0.8 + 0.3 * Math.sin(time*3 + i*0.05));
                dummy.scale.set(scale, scale, scale);
                dummy.rotation.set(time+i, time*0.5+i, 0);

                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
                
                tempColor.setRGB(currentColors[ix], currentColors[iy], currentColors[iz]);
                mesh.setColorAt(i, tempColor);
            }
            mesh.instanceMatrix.needsUpdate = true;
            mesh.instanceColor.needsUpdate = true;

            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
