<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿äº¤äº’1.4</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%); }
        
        #video-input { position: absolute; bottom: 10px; left: 10px; width: 120px; height: 90px; transform: scaleX(-1); border-radius: 8px; opacity: 0.5; z-index: 2; border: 1px solid rgba(255,255,255,0.2); pointer-events: none; }
        #video-input.active { opacity: 0.9; }
        
        #fs-btn {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            background: rgba(255, 255, 255, 0.1); color: white; border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 15px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(5px);
            transition: all 0.3s; font-size: 14px;
        }
        #fs-btn:hover { background: white; color: black; }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00f2ff; font-size: 20px; z-index: 20; pointer-events: none;
            text-shadow: 0 0 15px rgba(0,242,255,0.5); letter-spacing: 2px; text-align: center;
        }
        .lil-gui { --width: 280px; --name-width: 40%; }
    </style>
</head>
<body>

    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <button id="fs-btn">â›¶ å…¨å±æ²‰æµ¸</button>
    <div id="loader">æ­£åœ¨åŠ è½½è§†è§‰æ ¸å¿ƒ...<br><span style="font-size:14px; opacity:0.7;">é¦–æ¬¡è¿è¡Œè¯·å…è®¸æ‘„åƒå¤´/éº¦å…‹é£æƒé™</span></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        // å†…éƒ¨å™ªå£°ç±»
        class ImprovedNoise {
            constructor() {
                const p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
                for(let i=0; i<256; i++) p[256+i] = p[i];
                this.p = p;
            }
            noise(x, y, z) {
                const p = this.p, fade = t => t * t * t * (t * (t * 6 - 15) + 10), lerp = (t, a, b) => a + t * (b - a);
                const grad = (hash, x, y, z) => { const h = hash & 15; const u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z; return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v); };
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
                x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                const u = fade(x), v = fade(y), w = fade(z);
                const A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;
                return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z)), lerp(u, grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z))), lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1)), lerp(u, grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1))));
            }
        }

        const config = {
            mode: 'morph',
            shape: 'solidHeart',
            // color: '#ff0066', // ç§»é™¤å•è‰²å®šä¹‰
            particleCount: 16000, // å¢åŠ ç²’å­æ•°é‡åˆ° 16000
            particleSize: 0.1, // ç¨å¾®è°ƒå°ä¸€ç‚¹ç‚¹ä»¥é€‚åº”é«˜å¯†åº¦
            handSensitivity: 2.5,
            audioReactivity: false,
            autoRotate: true,
            clearTrail: () => { if(trailSystem) trailSystem.clear(); }
        };

        // å®šä¹‰éœ“è™¹è‰²æ¿ (ç«çº¢, é’è“, é‡‘é»„, çº¯ç™½)
        const colorPalette = [0xff0055, 0x00ddff, 0xffdd00, 0xffffff];

        let handData = { detected: false, distanceRaw: 0, distanceSmooth: 0, indexTipPos: new THREE.Vector3() };
        let audioContext, analyser, dataArray;
        let audioLevelRaw = 0, audioLevelSmooth = 0;

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.z = 30; // ç¨å¾®æ‹‰è¿œä¸€ç‚¹ç›¸æœº

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotateSpeed = 0.5;

        // --- ç²’å­ç³»ç»Ÿåˆå§‹åŒ– ---
        let mainPoints, mainGeometry, mainMaterial;
        const targetPositions = [];
        const noise = new ImprovedNoise();

        function initMainParticles() {
            if (mainPoints) scene.remove(mainPoints);
            const posArray = new Float32Array(config.particleCount * 3);
            const colorsArray = new Float32Array(config.particleCount * 3);
            const tempColor = new THREE.Color();

            for (let i = 0; i < config.particleCount; i++) {
                // åˆå§‹ä½ç½®åˆ†æ•£å¼€
                const x = (Math.random()-0.5)*60;
                const y = (Math.random()-0.5)*60;
                const z = (Math.random()-0.5)*60;
                posArray[i * 3] = x; posArray[i * 3 + 1] = y; posArray[i * 3 + 2] = z;

                // --- ç‚«å½©é€»è¾‘ï¼šä»è‰²æ¿ä¸­éšæœºé€‰å–é¢œè‰² ---
                const randomColorHex = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                tempColor.setHex(randomColorHex);
                
                colorsArray[i * 3] = tempColor.r; 
                colorsArray[i * 3 + 1] = tempColor.g; 
                colorsArray[i * 3 + 2] = tempColor.b;
            }

            mainGeometry = new THREE.BufferGeometry();
            mainGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            mainGeometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));

            mainMaterial = new THREE.PointsMaterial({
                size: config.particleSize,
                vertexColors: true, // å¯ç”¨é¡¶ç‚¹é¢œè‰²
                transparent: true,
                opacity: 0.85,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: createParticleTexture()
            });

            mainPoints = new THREE.Points(mainGeometry, mainMaterial);
            scene.add(mainPoints);
            calculateTargetShape(config.shape);
        }
        
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(255,255,255,0.9)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function calculateTargetShape(shapeType) {
            targetPositions.length = 0;
            let x, y, z;
            for (let i = 0; i < config.particleCount; i++) {
                if (shapeType === 'solidHeart') {
                    // --- å…¨æ–°çš„å‚æ•°åŒ–çˆ±å¿ƒç®—æ³• ---
                    const t = Math.random() * Math.PI * 2;
                    // ä½¿ç”¨ sqrt ç¡®ä¿åœ¨åœ†å†…å‡åŒ€åˆ†å¸ƒï¼Œè€Œä¸æ˜¯èšé›†åœ¨ä¸­å¿ƒ
                    const r = Math.sqrt(Math.random()); 
                    
                    // ç»å…¸çš„ 2D çˆ±å¿ƒå…¬å¼
                    const x2d = 16 * Math.pow(Math.sin(t), 3);
                    const y2d = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);

                    // åº”ç”¨åŠå¾„ç¼©æ”¾ä»¥å¡«å……å†…éƒ¨ï¼Œå¹¶æ•´ä½“ç¼©å°ä¸€ç‚¹é€‚åº”å±å¹•
                    x = x2d * r * 0.8;
                    y = y2d * r * 0.8;
                    
                    // æ·»åŠ åšåº¦ (Zè½´)ã€‚è¾¹ç¼˜è–„ï¼Œä¸­é—´åšã€‚
                    const thickness = 6 * (1 - r * 0.5); // ç¨å¾®è°ƒæ•´åšåº¦åˆ†å¸ƒ
                    z = (Math.random() - 0.5) * thickness;

                    // ç¨å¾®å‘ä¸Šç§»åŠ¨ä¸­å¿ƒ
                    y += 5;

                } else if (shapeType === 'sphere') {
                    const r = 15 * Math.cbrt(Math.random()); // ç¨å¾®åŠ å¤§åŠå¾„
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta); y = r * Math.sin(phi) * Math.sin(theta); z = r * Math.cos(phi);
                } else if (shapeType === 'torusKnot') {
                    const t = (i / config.particleCount) * Math.PI * 2 * 3;
                    const r = 9 + 3 * Math.cos(3 * t); // ç¨å¾®åŠ å¤§
                    x = r * Math.cos(2 * t); y = r * Math.sin(2 * t); z = 7 * Math.sin(3 * t);
                    // å¢åŠ æ›´å¤šéšæœºå¡«å……è®©å®ƒæ›´æ‰å®
                    x += (Math.random()-0.5)*2.5; y += (Math.random()-0.5)*2.5; z += (Math.random()-0.5)*2.5;
                } else if (shapeType === 'dna') {
                    const t = (i / config.particleCount) * Math.PI * 14; // å¢åŠ èºæ—‹å¯†åº¦
                    const yPos = (i / config.particleCount - 0.5) * 40; // æ‹‰é•¿
                    const offset = i % 2 === 0 ? 0 : Math.PI; 
                    const radius = 7;
                    x = radius * Math.cos(t + offset); z = radius * Math.sin(t + offset); y = yPos;
                    // å¢åŠ æ›´å¤šæ‚ä¹±å¡«å……
                    if (Math.random() > 0.7) { x *= Math.random()*1.5; z *= Math.random()*1.5; }
                }
                targetPositions.push(x, y, z);
            }
        }

        // ç”»ç¬”ç³»ç»Ÿ (ä½¿ç”¨å›ºå®šé¢œè‰²ï¼Œå› ä¸ºå®ƒæ˜¯è½¨è¿¹)
        const trailSystem = {
            maxParticles: 3000,
            geometry: null, material: null, points: null,
            positions: null, opacities: null, headIndex: 0,
            init: function() {
                this.positions = new Float32Array(this.maxParticles * 3);
                this.opacities = new Float32Array(this.maxParticles);
                for(let i=0; i<this.maxParticles; i++) this.positions[i*3 + 1] = 9999;
                this.geometry = new THREE.BufferGeometry();
                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('opacityAttr', new THREE.BufferAttribute(this.opacities, 1));
                this.material = new THREE.ShaderMaterial({
                    uniforms: { color: { value: new THREE.Color(0x00ddff) }, pointTexture: { value: createParticleTexture() } }, // ç”»ç¬”é»˜è®¤é’è‰²
                    vertexShader: `attribute float opacityAttr; varying float vOpacity; void main() { vOpacity = opacityAttr; vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); gl_PointSize = 20.0 * ( 1.0 / - mvPosition.z ) * vOpacity; gl_Position = projectionMatrix * mvPosition; }`,
                    fragmentShader: `uniform vec3 color; uniform sampler2D pointTexture; varying float vOpacity; void main() { if (vOpacity <= 0.01) discard; gl_FragColor = vec4( color, vOpacity ); gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord ); }`,
                    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
                });
                this.points = new THREE.Points(this.geometry, this.material);
                scene.add(this.points);
                this.points.visible = false;
            },
            update: function(targetPos, isDrawing) {
                if (!this.points.visible) return;
                for (let i = 0; i < this.maxParticles; i++) this.opacities[i] *= 0.96;
                if (isDrawing && targetPos) {
                    this.headIndex = (this.headIndex + 1) % this.maxParticles;
                    const idx = this.headIndex * 3;
                    this.positions[idx] = targetPos.x; this.positions[idx + 1] = targetPos.y; this.positions[idx + 2] = targetPos.z;
                    this.opacities[this.headIndex] = 1.0;
                }
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.opacityAttr.needsUpdate = true;
            },
            clear: function() {
                 for(let i=0; i<this.maxParticles; i++) this.opacities[i] = 0;
                 this.geometry.attributes.opacityAttr.needsUpdate = true;
            }
        };

        async function setupAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                audioContext.createMediaStreamSource(stream).connect(analyser);
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            } catch (e) {
                console.warn("Audio init failed", e);
                config.audioReactivity = false;
            }
        }

        const videoElement = document.getElementById('video-input');
        function onHandsResults(results) {
            document.getElementById('loader').style.display = 'none';
            videoElement.classList.add('active');
            handData.detected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;
            if (handData.detected) {
                const hands = results.multiHandLandmarks;
                let newDistance = 0;
                if (hands.length === 2) {
                    const h1 = hands[0][0]; const h2 = hands[1][0];
                    newDistance = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                } else if (hands.length === 1) {
                    const h1 = hands[0][4]; const h2 = hands[0][8];
                    newDistance = Math.hypot(h1.x - h2.x, h1.y - h2.y) * 2.0;
                }
                handData.distanceRaw = Math.max(0, (newDistance - 0.1) * config.handSensitivity);

                const indexTip2D = hands[0][8];
                const vec = new THREE.Vector3((indexTip2D.x * 2) - 1, -(indexTip2D.y * 2) + 1, 0.5);
                vec.unproject(camera);
                vec.sub(camera.position).normalize();
                handData.indexTipPos.lerp(camera.position.clone().add(vec.multiplyScalar(25)), 0.2);
            } else {
                handData.distanceRaw = 0;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onHandsResults);
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });

        const gui = new GUI({ title: 'æ§åˆ¶ç»ˆç«¯ v4.0' });
        gui.add(config, 'mode', { 'æ‰‹åŠ¿å˜å½¢ (Morph)': 'morph', 'è™šç©ºç”»ç¬” (Draw)': 'draw' }).name('äº¤äº’æ¨¡å¼').onChange(mode => {
               mainPoints.visible = (mode === 'morph');
               trailSystem.points.visible = (mode === 'draw');
               if (mode === 'draw') trailSystem.clear();
        });
        const f1 = gui.addFolder('å˜å½¢è®¾ç½® (å¤šè‰²)').close();
        f1.add(config, 'shape', { 'æ ‡å‡†çˆ±å¿ƒ': 'solidHeart', 'ç¯é¢ç»“': 'torusKnot', 'DNA': 'dna', 'çƒä½“': 'sphere' }).onChange(v => calculateTargetShape(v));
        // ç§»é™¤äº†å•è‰²é€‰æ‹©å™¨ï¼Œå› ä¸ºç°åœ¨æ˜¯å¤šè‰²çš„
        f1.add(config, 'audioReactivity').name('ğŸµ éŸ³é¢‘è·³åŠ¨').onChange(v => { if (v && !audioContext) setupAudio(); });
        gui.add(config, 'clearTrail').name('æ¸…é™¤ç¬”è¿¹');
        gui.close();

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.autoRotate = config.autoRotate;
            controls.update();

            handData.distanceSmooth += (handData.distanceRaw - handData.distanceSmooth) * 0.1;
            
            if (config.audioReactivity && analyser) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0; for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
                audioLevelRaw = sum / dataArray.length / 256;
                audioLevelSmooth += (audioLevelRaw - audioLevelSmooth) * 0.2;
            } else audioLevelSmooth = 0;

            if (config.mode === 'morph') {
                const positions = mainGeometry.attributes.position.array;
                let baseScale = 1.0 + handData.distanceSmooth * 1.2;
                let audioScaleBump = 1.0 + audioLevelSmooth * 0.8; 

                for (let i = 0; i < config.particleCount; i++) {
                    const ix = i * 3; const iy = i * 3 + 1; const iz = i * 3 + 2;
                    let tx = targetPositions[ix] * baseScale * audioScaleBump;
                    let ty = targetPositions[iy] * baseScale * audioScaleBump;
                    let tz = targetPositions[iz] * baseScale * audioScaleBump;

                    const noiseIntensity = 0.3 + audioLevelSmooth * 1.5; 
                    // ç¨å¾®é™ä½äº†ä¸€ç‚¹å™ªç‚¹é€Ÿåº¦ï¼Œè®©è¿åŠ¨æ›´ä¼˜é›…
                    tx += noise.noise(positions[ix]*0.05, positions[iy]*0.05, positions[iz]*0.05 + time*0.3) * noiseIntensity;
                    ty += noise.noise(positions[ix]*0.05 + 100, positions[iy]*0.05, positions[iz]*0.05 + time*0.3) * noiseIntensity;
                    tz += noise.noise(positions[ix]*0.05 + 200, positions[iy]*0.05, positions[iz]*0.05 + time*0.3) * noiseIntensity;
                    
                    positions[ix] += (tx - positions[ix]) * 0.06;
                    positions[iy] += (ty - positions[iy]) * 0.06;
                    positions[iz] += (tz - positions[iz]) * 0.06;
                }
                mainGeometry.attributes.position.needsUpdate = true;
                // æ ¹æ®éŸ³é¢‘ç¨å¾®è°ƒæ•´ç²’å­å¤§å°
                mainMaterial.size = config.particleSize * (1 + audioLevelSmooth * 1.2);
            } else {
                trailSystem.update(handData.indexTipPos, handData.detected);
            }
            renderer.render(scene, camera);
        }

        initMainParticles();
        trailSystem.init();
        cameraUtils.start().catch(e=>console.error(e));
        animate();

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        document.getElementById('fs-btn').addEventListener('click', () => { if (!document.fullscreenElement) document.body.requestFullscreen(); else document.exitFullscreen(); });
    </script>
</body>
</html>
