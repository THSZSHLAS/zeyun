<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è”šè“æ˜Ÿæ ¸v11</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #02040a; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* æ‘„åƒå¤´é¢„è§ˆï¼šç§‘æŠ€æ„Ÿè¾¹æ¡†ï¼ŒåŠé€æ˜ */
        #video-input { 
            position: absolute; bottom: 15px; left: 15px; width: 140px; height: 105px; 
            transform: scaleX(-1); border-radius: 4px; opacity: 0.2; z-index: 2; 
            border: 1px solid rgba(79, 172, 254, 0.5); 
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.2);
            pointer-events: none; transition: opacity 0.3s; mix-blend-mode: screen; 
        }
        #video-input.active { opacity: 0.6; }
        
        /* æ²‰æµ¸æŒ‰é’® */
        #fs-btn {
            position: absolute; top: 20px; right: 20px; z-index: 10;
            background: rgba(0, 10, 30, 0.6); color: #4facfe; border: 1px solid #4facfe;
            padding: 8px 20px; border-radius: 4px; cursor: pointer; backdrop-filter: blur(5px);
            transition: all 0.3s; font-size: 12px; letter-spacing: 2px; text-transform: uppercase;
            box-shadow: 0 0 10px rgba(79, 172, 254, 0.3);
        }
        #fs-btn:hover { background: #4facfe; color: #000; box-shadow: 0 0 25px rgba(79, 172, 254, 0.8); }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #4facfe; font-size: 16px; z-index: 20; pointer-events: none;
            text-align: center; font-weight: 300; letter-spacing: 4px;
            text-shadow: 0 0 20px rgba(79, 172, 254, 1);
        }

        /* GUI æ·±åº¦å®šåˆ¶ - èµ›åšæœ‹å…‹è“ */
        .lil-gui { 
            --width: 260px; --name-width: 40%; 
            --background-color: rgba(2, 6, 15, 0.85); 
            --text-color: #aaddff; 
            --widget-color: #0f2a4a; 
            --hover-color: #1a4060;
            --focus-color: #4facfe; 
            border: 1px solid rgba(79, 172, 254, 0.3);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
        }
        .lil-gui .title { color: #4facfe; text-shadow: 0 0 5px #4facfe; font-weight: bold; }
    </style>
</head>
<body>

    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <button id="fs-btn">Start Immersive</button>
    <div id="loader">INITIALIZING CORE...<br><span style="font-size:12px; opacity:0.6;">Allow Camera for Hand Interaction</span></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // --- æ ¸å¿ƒé…ç½® ---
        const config = {
            target: 'earth', 
            particleCount: 75000, // å¢åŠ ç²’å­å¯†åº¦
            particleSize: 0.04,   // æå°ç²’å­ï¼Œé å…‰æ™•
            bloomStrength: 1.8,   // å¼ºè¾‰å…‰
            bloomRadius: 0.5,
            bloomThreshold: 0.05,
            interactionRadius: 12, // æ‰‹åŠ¿æ–¥åŠ›åœºåŠå¾„
            interactionForce: 0.8, // æ–¥åŠ›å¼ºåº¦
            autoRotate: true
        };

        // --- é¢œè‰²å®šä¹‰ (åŸºäºä½ çš„è¦æ±‚) ---
        // ä¸»è‰²ï¼šrgba(79, 172, 254) -> Hex: #4facfe
        const palette = {
            main: new THREE.Color(0x4facfe),  // å¤©è“
            cyan: new THREE.Color(0x00f2fe),  // é’
            deep: new THREE.Color(0x051937),  // æ·±è“èƒŒæ™¯
            white: new THREE.Color(0xffffff)
        };

        // --- ImprovedNoise ---
        class ImprovedNoise{constructor(){const p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];for(let i=0;i<256;i++)p[256+i]=p[i];this.p=p}noise(x,y,z){const p=this.p,fade=t=>t*t*t*(t*(t*6-15)+10),lerp=(t,a,b)=>a+t*(b-a),grad=(hash,x,y,z)=>{const h=hash&15,u=h<8?x:y,v=h<4?y:h===12||h===14?x:z;return((h&1)===0?u:-u)+((h&2)===0?v:-v)};const X=Math.floor(x)&255,Y=Math.floor(y)&255,Z=Math.floor(z)&255;x-=Math.floor(x);y-=Math.floor(y);z-=Math.floor(z);const u=fade(x),v=fade(y),w=fade(z);const A=p[X]+Y,AA=p[A]+Z,AB=p[A+1]+Z,B=p[X+1]+Y,BA=p[B]+Z,BB=p[B+1]+Z;return lerp(w,lerp(v,lerp(u,grad(p[AA],x,y,z),grad(p[BA],x-1,y,z)),lerp(u,grad(p[AB],x,y-1,z),grad(p[BB],x-1,y-1,z))),lerp(v,lerp(u,grad(p[AA+1],x,y,z-1),grad(p[BA+1],x-1,y,z-1)),lerp(u,grad(p[AB+1],x,y-1,z-1),grad(p[BB+1],x-1,y-1,z-1))))}}

        // --- ç›®æ ‡æ•°æ® (å…¨éƒ¨ä½¿ç”¨è“è‰²ç³») ---
        const targets = {
            'sun': { type: 'sun', radius: 20 },
            'earth': { type: 'earth', radius: 14 },
            'saturn': { type: 'ringed', radius: 12 },
            'galaxy': { type: 'galaxy', radius: 30 }
        };

        // --- åœºæ™¯ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x02040a, 0.002); // é»‘è‰²è¿·é›¾

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // --- Post Processing ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), config.bloomStrength, config.bloomRadius, config.bloomThreshold);
        composer.addPass(bloom);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- èƒŒæ™¯æ˜Ÿå°˜ ---
        function createStarField() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const cols = [];
            for(let i=0; i<4000; i++) {
                const r = 100 + Math.random() * 300;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                pos.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                
                // è“ç™½è‰²æ˜Ÿæ˜Ÿ
                const c = Math.random() > 0.5 ? palette.cyan : palette.white;
                cols.push(c.r, c.g, c.b);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
            const mat = new THREE.PointsMaterial({ size: 0.6, vertexColors: true, transparent: true, opacity: 0.4, map: createGlowTexture(), depthWrite: false });
            scene.add(new THREE.Points(geo, mat));
        }
        
        // --- ç²’å­çº¹ç† ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.3, 'rgba(255,255,255,0.5)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- æ ¸å¿ƒå˜é‡ ---
        let points;
        const targetPositions = new Float32Array(config.particleCount * 3);
        const originalPositions = new Float32Array(config.particleCount * 3); // ç”¨äºæ¢å¤
        const noise = new ImprovedNoise();
        
        // æ‰‹åŠ¿æ•°æ®
        const handPos = new THREE.Vector3(999, 999, 999); // é»˜è®¤åœ¨å±å¹•å¤–
        let isHandActive = false;

        // --- åˆå§‹åŒ–ç²’å­ ---
        function initParticles() {
            if(points) scene.remove(points);
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(config.particleCount * 3);
            const col = new Float32Array(config.particleCount * 3);
            
            for(let i=0; i<config.particleCount; i++) {
                pos[i*3] = (Math.random()-0.5)*100;
                pos[i*3+1] = (Math.random()-0.5)*100;
                pos[i*3+2] = (Math.random()-0.5)*100;
                
                // é»˜è®¤é¢œè‰²ï¼šä¸»è‰²æ··ä¸€ç‚¹ç™½
                const c = palette.main.clone().lerp(palette.cyan, Math.random()*0.5);
                col[i*3] = c.r; col[i*3+1] = c.g; col[i*3+2] = c.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

            const mat = new THREE.PointsMaterial({
                size: config.particleSize,
                vertexColors: true,
                map: createGlowTexture(),
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            points = new THREE.Points(geo, mat);
            scene.add(points);
            
            // åˆå§‹ç›®æ ‡
            calculateTarget('earth');
        }

        // --- ç›®æ ‡å½¢çŠ¶è®¡ç®— (ç§‘å¹»è“é£æ ¼) ---
        function calculateTarget(key) {
            const data = targets[key];
            const rBase = data.radius;
            
            for(let i=0; i<config.particleCount; i++) {
                let x, y, z;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // é€šç”¨çƒä½“
                let r = rBase; 

                if (data.type === 'sun') {
                    // å¤ªé˜³ï¼šçˆ†è£‚æ ¸å¿ƒ
                    r = rBase * (0.8 + Math.random()*0.4);
                    // åŠ¨æ€å–·å°„ç²’å­
                    if (Math.random() > 0.8) r *= 1.5;
                } 
                else if (data.type === 'earth') {
                    // åœ°çƒï¼šå…¨æ¯åœ°å½¢
                    r = rBase;
                    const land = noise.noise(Math.sin(phi)*3, Math.cos(theta)*3, 0);
                    if (land > 0.5) r += 0.5; // é™†åœ°å‡¸èµ·
                }
                else if (data.type === 'ringed') {
                    // åœŸæ˜Ÿå…‰ç¯
                    if (Math.random() > 0.5) {
                        // ç¯
                        const ringR = rBase * (1.4 + Math.random());
                        x = ringR * Math.cos(theta);
                        z = ringR * Math.sin(theta);
                        y = (Math.random()-0.5) * 0.2;
                    } else {
                        // æœ¬ä½“
                        r = rBase * 0.9;
                    }
                }
                else if (data.type === 'galaxy') {
                    // æ—‹è‡‚
                    const arm = i % 3;
                    const dist = Math.random();
                    r = dist * rBase * 1.5;
                    const angle = theta + dist * 5 + (arm * Math.PI * 2 / 3);
                    x = r * Math.cos(angle);
                    z = r * Math.sin(angle);
                    y = (Math.random()-0.5) * (1-dist) * 5;
                }

                if (x === undefined) {
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                targetPositions[i*3] = x;
                targetPositions[i*3+1] = y;
                targetPositions[i*3+2] = z;
            }
        }

        // --- MediaPipe æ‰‹åŠ¿æ˜ å°„ ---
        const videoElement = document.getElementById('video-input');
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            videoElement.classList.add('active');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandActive = true;
                const hand = results.multiHandLandmarks[0];
                const indexTip = hand[8]; // é£ŸæŒ‡æŒ‡å°–
                
                // å°† 2D åæ ‡ (0-1) æ˜ å°„åˆ° 3D æ‘„åƒæœºå¹³é¢çš„å¤§æ¦‚ä½ç½®
                // è¿™é‡Œåšä¸€ä¸ªè¿‘ä¼¼æ˜ å°„ï¼Œå‡è®¾æ‰‹åœ¨ z=0 å¹³é¢é™„è¿‘ç§»åŠ¨
                const vector = new THREE.Vector3(
                    (indexTip.x * 2) - 1,
                    -(indexTip.y * 2) + 1,
                    0.5
                );
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                
                // å¹³æ»‘ç§»åŠ¨
                handPos.lerp(pos, 0.1);
            } else {
                isHandActive = false;
                handPos.set(999, 999, 999); // ç§»å‡ºå±å¹•
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });

        // --- åˆå§‹åŒ–åºåˆ— ---
        createGlowTexture();
        createStarField();
        initParticles(); // å…ˆåˆå§‹åŒ–ç²’å­
        cameraUtils.start(); // å†å¯åŠ¨æ‘„åƒå¤´

        // --- GUI (æ”¾åœ¨æœ€å) ---
        const gui = new GUI({ title: 'HOLOGRAPHIC CORE' });
        const targetNames = { 'â˜€ï¸ Sun': 'sun', 'ğŸŒ Earth': 'earth', 'ğŸª Saturn': 'saturn', 'ğŸŒŒ Galaxy': 'galaxy' };
        gui.add(config, 'target', targetNames).onChange(v => calculateTarget(v));
        
        const f = gui.addFolder('Interaction');
        f.add(config, 'interactionRadius', 5, 30).name('Force Radius');
        f.add(config, 'interactionForce', 0.1, 2.0).name('Force Strength');
        f.add(config, 'bloomStrength', 0, 3).name('Glow Level').onChange(v => bloom.strength = v);

        // --- åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            controls.autoRotate = config.autoRotate;
            controls.update();

            const positions = points.geometry.attributes.position.array;
            
            for(let i=0; i<config.particleCount; i++) {
                const ix = i*3; const iy = i*3+1; const iz = i*3+2;
                
                // 1. è·å–ç›®æ ‡ä½ç½®
                let tx = targetPositions[ix];
                let ty = targetPositions[iy];
                let tz = targetPositions[iz];

                // 2. å™ªç‚¹å‘¼å¸ (å‘¼å¸æ„Ÿ)
                const n = noise.noise(tx*0.05, ty*0.05, time*0.5) * 1.5;
                tx += n; ty += n; tz += n;

                // 3. æ–¥åŠ›åœº (Repulsion Logic)
                // åªæœ‰å½“æ‰‹æ¿€æ´»æ—¶è®¡ç®—
                if (isHandActive) {
                    const dx = tx - handPos.x;
                    const dy = ty - handPos.y;
                    const dz = tz - handPos.z;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    const radiusSq = config.interactionRadius * config.interactionRadius;

                    if (distSq < radiusSq) {
                        const dist = Math.sqrt(distSq);
                        const force = (config.interactionRadius - dist) / config.interactionRadius; // 0-1
                        // å‘å¤–æ¨
                        const angleX = dx / dist;
                        const angleY = dy / dist;
                        const angleZ = dz / dist;
                        
                        const push = force * config.interactionForce * 20; // æ–¥åŠ›ç³»æ•°
                        
                        tx += angleX * push;
                        ty += angleY * push;
                        tz += angleZ * push;
                    }
                }

                // 4. å¹³æ»‘æ›´æ–°ä½ç½® (Lerp)
                positions[ix] += (tx - positions[ix]) * 0.08;
                positions[iy] += (ty - positions[iy]) * 0.08;
                positions[iz] += (tz - positions[iz]) * 0.08;
            }

            points.geometry.attributes.position.needsUpdate = true;
            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        document.getElementById('fs-btn').addEventListener('click', () => {
             if (!document.fullscreenElement) document.body.requestFullscreen();
             else document.exitFullscreen();
        });
    </script>
</body>
</html>
