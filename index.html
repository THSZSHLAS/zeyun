<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨æ¯æ™¶ä½“ v13</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Courier New', monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* æ‘„åƒå¤´é¢„è§ˆ */
        #video-input { 
            position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px; 
            transform: scaleX(-1); opacity: 0.25; z-index: 2; 
            border: 2px solid #4facfe; border-radius: 4px;
            pointer-events: none; mix-blend-mode: screen;
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.4);
        }
        
        /* é¡¶éƒ¨ HUD */
        #hud-top {
            position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; z-index: 5;
        }
        .hud-text {
            color: #4facfe; font-size: 14px; letter-spacing: 4px; text-transform: uppercase;
            text-shadow: 0 0 10px rgba(79, 172, 254, 0.8); background: rgba(0,0,0,0.5);
            padding: 5px 15px; border: 1px solid rgba(79, 172, 254, 0.3); display: inline-block;
        }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 14px; z-index: 20; pointer-events: none;
            letter-spacing: 4px; text-transform: uppercase; border: 1px solid #4facfe;
            padding: 15px 30px; background: rgba(0,0,0,0.8);
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.3);
        }

        /* GUI å®šåˆ¶ */
        .lil-gui { 
            --background-color: rgba(5, 8, 15, 0.9); 
            --text-color: #eee; 
            --title-background-color: #0b1a2f;
            --widget-color: #222;
            --focus-color: #4facfe;
            --width: 240px;
            border: 1px solid rgba(79, 172, 254, 0.5);
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.15);
        }
        .lil-gui .title { color: #4facfe; font-weight: bold; }
    </style>
</head>
<body>

    <div id="hud-top"><span class="hud-text">SOLAR SYSTEM DATABASE_V13</span></div>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <div id="loader">Initializing Voxel Engine...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // --- æ ¸å¿ƒé…ç½® ---
        const config = {
            count: 6000,          // ç²’å­æ•°é‡
            voxelSize: 0.4,       // æ™¶ä½“å¤§å°
            target: 'earth',      // é»˜è®¤ç›®æ ‡
            bloomStrength: 1.6,   // è¾‰å…‰å¼ºåº¦
            bloomRadius: 0.5,
            handZoomSpeed: 0.1,
            handRotateSpeed: 3.0,
            autoRotate: true
        };

        // --- éœ“è™¹è°ƒè‰²æ¿ (Cyber Palette) ---
        const colors = {
            blue: new THREE.Color(0x4facfe),     // ä¸»è‰²è°ƒ
            cyan: new THREE.Color(0x00f2fe),     // é’
            white: new THREE.Color(0xffffff),    // ç™½
            purple: new THREE.Color(0x9b59b6),   // ç´« (é“¶æ²³)
            gold: new THREE.Color(0xffd700),     // é‡‘ (åœŸæ˜Ÿ/é‡‘æ˜Ÿ)
            orange: new THREE.Color(0xff8c00),   // æ©™ (å¤ªé˜³/æœ¨æ˜Ÿ)
            red: new THREE.Color(0xff3333),      // çº¢ (ç«æ˜Ÿ)
            deepBlue: new THREE.Color(0x00008b), // æ·±è“ (æµ·ç‹æ˜Ÿ)
            grey: new THREE.Color(0xa9a9a9)      // ç° (æ°´æ˜Ÿ)
        };

        // --- åœºæ™¯æ­å»º ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020204); 
        scene.fog = new THREE.FogExp2(0x020204, 0.02);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 35;

        const renderer = new THREE.WebGLRenderer({ antialias: false }); 
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // --- Bloom ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = config.bloomStrength;
        bloomPass.radius = config.bloomRadius;
        composer.addPass(bloomPass);

        // --- InstancedMesh ---
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({ color: 0xffffff }); 
        const mesh = new THREE.InstancedMesh(geometry, material, config.count);
        scene.add(mesh);

        const dummy = new THREE.Object3D();
        const positions = [];       
        const targetPositions = []; 
        const currentColors = [];   
        const targetColors = [];    

        // åˆå§‹åŒ–æ•°ç»„
        for(let i=0; i<config.count; i++) {
            positions.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
            targetPositions.push(0,0,0);
            currentColors.push(0,0,1);
            targetColors.push(0,0,1);
        }

        // --- ç®€å•å™ªå£°å‡½æ•° ---
        function simpleNoise(x, y, z) {
            return Math.sin(x*10 + Math.cos(y*12 + z*15)) * 0.5 + 0.5;
        }

        // --- ğŸª å¤ªé˜³ç³»å…¨å®¶æ¡¶ç”Ÿæˆé€»è¾‘ ---
        function calculateLayout(type) {
            const rBase = 12; // åŸºç¡€åŠå¾„

            for (let i = 0; i < config.count; i++) {
                let x, y, z;
                let c = colors.blue;
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // é»˜è®¤çƒä½“åæ ‡
                let r = rBase;
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);

                // --- æ˜Ÿçƒç‰¹è‰²é€»è¾‘ ---

                if (type === 'sun') { // â˜€ï¸ å¤ªé˜³
                    r = rBase * (0.7 + Math.random() * 0.4);
                    const spike = Math.random() > 0.9 ? 1.4 : 1.0;
                    x = r * spike * Math.sin(phi) * Math.cos(theta);
                    y = r * spike * Math.sin(phi) * Math.sin(theta);
                    z = r * spike * Math.cos(phi);
                    
                    const mix = Math.random();
                    if(mix > 0.6) c = colors.white;
                    else if(mix > 0.2) c = colors.orange;
                    else c = colors.gold;

                } else if (type === 'mercury') { // ğŸŒ‘ æ°´æ˜Ÿ (å°ï¼Œç°è“)
                    r = rBase * 0.6; // å°
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    // è¡¨é¢ç²—ç³™
                    if (Math.random() > 0.8) { x*=0.95; y*=0.95; z*=0.95; }
                    c = colors.grey.clone().lerp(colors.blue, 0.3); // ç§‘æŠ€ç°

                } else if (type === 'venus') { // ğŸŒ• é‡‘æ˜Ÿ (äº®ï¼Œè‡´å¯†å¤§æ°”)
                    r = rBase * 0.9;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    // éå¸¸äº®
                    c = colors.gold.clone().lerp(colors.white, Math.random()*0.5);

                } else if (type === 'earth') { // ğŸŒ åœ°çƒ (åˆ†å±‚)
                    r = rBase;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    
                    const noiseVal = simpleNoise(x*0.1, y*0.1, z*0.1);
                    if (noiseVal > 0.65) {
                        c = new THREE.Color(0x22ee22); // äº®ç»¿
                        x *= 1.03; y *= 1.03; z *= 1.03; 
                    } else if (Math.random() > 0.9) {
                         c = colors.white; // äº‘
                         x *= 1.1; y *= 1.1; z *= 1.1;
                    } else {
                        c = colors.blue.clone().lerp(colors.deepBlue, Math.random()); // æ·±è“æµ·
                    }

                } else if (type === 'mars') { // ğŸ”´ ç«æ˜Ÿ (çº¢ï¼Œä¹±)
                    r = rBase * 0.7;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    
                    const rough = simpleNoise(x*0.2, y*0.2, z*0.2);
                    if(rough > 0.6) { x*=1.05; y*=1.05; z*=1.05; } // é«˜åœ°
                    c = colors.red.clone().lerp(colors.orange, Math.random()*0.5);

                } else if (type === 'jupiter') { // ğŸ˜ æœ¨æ˜Ÿ (æ¡çº¹)
                    r = rBase * 1.4; // å·¨å¤§
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    
                    // æ¡çº¹é€»è¾‘ (åŸºäºYè½´)
                    const band = Math.sin(y * 1.5 + simpleNoise(x,0,z)); 
                    if (band > 0.5) c = colors.orange;
                    else if (band > 0) c = colors.gold.clone().multiplyScalar(0.8);
                    else c = colors.blue.clone().lerp(colors.grey, 0.5); // æš—å¸¦

                } else if (type === 'saturn') { // ğŸª åœŸæ˜Ÿ (ç¯)
                    if (i < config.count * 0.4) {
                        r = rBase * 1.1;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                        c = colors.gold.clone().multiplyScalar(0.7);
                    } else {
                        const ringR = rBase * (1.6 + Math.random()*1.2);
                        const angle = Math.random() * Math.PI * 2;
                        x = ringR * Math.cos(angle);
                        z = ringR * Math.sin(angle);
                        y = (Math.random()-0.5) * 0.6; 
                        c = colors.blue.clone().lerp(colors.white, Math.random());
                    }

                } else if (type === 'uranus') { // âš™ï¸ å¤©ç‹æ˜Ÿ (ç«–ç¯)
                    if (i < config.count * 0.5) {
                        r = rBase * 1.0;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                        c = colors.cyan;
                    } else {
                        // ç«–ç€çš„ç¯ (äº¤æ¢Xå’ŒYï¼Œæˆ–è€…Yå’ŒZ)
                        const ringR = rBase * (1.5 + Math.random()*0.8);
                        const angle = Math.random() * Math.PI * 2;
                        // åŸæœ¬æ˜¯ x, z å¹³é¢ï¼Œç°åœ¨è¦åœ¨ x, y å¹³é¢
                        x = ringR * Math.cos(angle);
                        y = ringR * Math.sin(angle);
                        z = (Math.random()-0.5) * 0.4;
                        c = colors.white.clone().multiplyScalar(0.8);
                    }

                } else if (type === 'neptune') { // ğŸ”µ æµ·ç‹æ˜Ÿ (æ·±è“ï¼Œé£æš´)
                    r = rBase * 1.0;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    
                    const storm = simpleNoise(x*0.3, y*0.3, z*0.3);
                    if(storm > 0.7) c = colors.blue; // äº®æ–‘
                    else c = colors.deepBlue;

                } else if (type === 'galaxy') { // ğŸŒŒ é“¶æ²³ (æ—‹è‡‚)
                    const arm = i % 4; // 4æ¡æ—‹è‡‚
                    r = Math.random() * rBase * 2.0;
                    const angle = r * 0.4 + (arm * Math.PI * 2 / 4);
                    x = r * Math.cos(angle) + (Math.random()-0.5)*3;
                    z = r * Math.sin(angle) + (Math.random()-0.5)*3;
                    y = (Math.random()-0.5) * (20 - r*0.6);
                    
                    const dist = r / (rBase*2);
                    if (dist < 0.15) c = colors.white; // æ ¸å¿ƒ
                    else if (dist < 0.5) c = colors.purple;
                    else c = colors.blue;
                }

                targetPositions[i*3] = x; targetPositions[i*3+1] = y; targetPositions[i*3+2] = z;
                targetColors[i*3] = c.r; targetColors[i*3+1] = c.g; targetColors[i*3+2] = c.b;
            }
        }

        // åˆå§‹åŠ è½½
        calculateLayout(config.target);

        // --- æ‰‹åŠ¿æ§åˆ¶é€»è¾‘ ---
        let targetZoom = 35; 
        let targetRotY = 0;
        
        const videoElement = document.getElementById('video-input');
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hands = results.multiHandLandmarks;
                
                let pinchDist = 0;
                let handCenterX = 0.5;

                if (hands.length === 2) {
                    const h1 = hands[0][0]; const h2 = hands[1][0];
                    pinchDist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                    handCenterX = (h1.x + h2.x) / 2;
                } else {
                    const thumb = hands[0][4]; const pinky = hands[0][20];
                    pinchDist = Math.hypot(thumb.x - pinky.x, thumb.y - pinky.y) * 2;
                    handCenterX = hands[0][9].x;
                }

                // ç¼©æ”¾
                const zoomFactor = 1.0 - Math.min(Math.max(pinchDist, 0.1), 0.8);
                targetZoom = 15 + zoomFactor * 50;

                // æ—‹è½¬
                targetRotY += (handCenterX - 0.5) * config.handRotateSpeed * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });
        cameraUtils.start();

        // --- GUI ---
        const gui = new GUI({ title: 'PLANETARY SYSTEM' });
        const celestialMap = { 
            'â˜€ï¸ Sun': 'sun', 
            'ğŸŒ‘ Mercury': 'mercury',
            'ğŸŒ• Venus': 'venus',
            'ğŸŒ Earth': 'earth',
            'ğŸ”´ Mars': 'mars',
            'ğŸ˜ Jupiter': 'jupiter',
            'ğŸª Saturn': 'saturn',
            'âš™ï¸ Uranus': 'uranus',
            'ğŸ”µ Neptune': 'neptune',
            'ğŸŒŒ Galaxy': 'galaxy' 
        };
        gui.add(config, 'target', celestialMap).name('Target').onChange(v => calculateLayout(v));
        gui.add(config, 'voxelSize', 0.1, 1.0).name('Voxel Size'); 
        gui.add(config, 'bloomStrength', 0, 3).name('Neon Glow').onChange(v => bloomPass.strength = v);
        gui.add(config, 'autoRotate').name('Auto Spin');

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. æ‘„åƒæœºä¸æ—‹è½¬
            camera.position.z += (targetZoom - camera.position.z) * 0.05;
            mesh.rotation.y += (targetRotY - mesh.rotation.y) * 0.05;
            if(config.autoRotate) mesh.rotation.y += config.autoRotateSpeed;
            mesh.rotation.x = Math.sin(Date.now()*0.0005) * 0.05;

            // 2. ç²’å­æ›´æ–°
            const time = Date.now() * 0.001;
            const tempColor = new THREE.Color();
            
            for (let i = 0; i < config.count; i++) {
                const ix = i * 3; const iy = i * 3 + 1; const iz = i * 3 + 2;
                
                // ä½ç½® Lerp
                positions[ix] += (targetPositions[ix] - positions[ix]) * 0.08;
                positions[iy] += (targetPositions[iy] - positions[iy]) * 0.08;
                positions[iz] += (targetPositions[iz] - positions[iz]) * 0.08;

                // é¢œè‰² Lerp
                currentColors[ix] += (targetColors[ix] - currentColors[ix]) * 0.05;
                currentColors[iy] += (targetColors[iy] - currentColors[iy]) * 0.05;
                currentColors[iz] += (targetColors[iz] - currentColors[iz]) * 0.05;

                dummy.position.set(positions[ix], positions[iy], positions[iz]);
                
                // å‘¼å¸æ•ˆæœ
                const breath = 0.8 + 0.3 * Math.sin(time * 3 + i * 0.05);
                const scale = config.voxelSize * breath;
                dummy.scale.set(scale, scale, scale);
                
                dummy.rotation.set(time + i, time * 0.5 + i, 0);

                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
                
                tempColor.setRGB(currentColors[ix], currentColors[iy], currentColors[iz]);
                mesh.setColorAt(i, tempColor);
            }
            mesh.instanceMatrix.needsUpdate = true;
            mesh.instanceColor.needsUpdate = true;

            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
